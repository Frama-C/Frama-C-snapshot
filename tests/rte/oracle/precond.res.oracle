[kernel] Parsing share/libc/__fc_builtin_for_normalization.i (no preprocessing)
[kernel] Parsing tests/rte/precond.c (with preprocessing)
tests/rte/precond.c:27:[kernel] warning: parsing obsolete ACSL construct '\valid_range(addr,min,max)'. '\valid(addr+(min..max))' should be used instead.
[rte] annotating function f
[rte] annotating function g
[rte] annotating function h
[rte] annotating function main
[rte] annotating function next_val
[rte] annotating function set
[rte] annotating function tabtop_set
[rte] annotating function top_next
[rte] annotating function top_set
/* Generated by Frama-C */
struct cell {
   int val ;
   struct cell *next ;
};
typedef struct cell cell;
struct other {
   cell c ;
};
typedef struct other other;
struct top {
   int topv ;
   cell *next ;
   cell *pred ;
};
typedef struct top top;
int global = 15;
/*@ requires x > 0;
    requires (int)(x+y) ≢ 0; */
int f(int x, int y, float z)
{
  int __retres;
  /*@ assert rte: signed_overflow: -2147483648 ≤ (int)(x+y)-(int)z; */
  /*@ assert rte: signed_overflow: (int)(x+y)-(int)z ≤ 2147483647; */
  /*@ assert rte: signed_overflow: -2147483648 ≤ x+y; */
  /*@ assert rte: signed_overflow: x+y ≤ 2147483647; */
  /*@ assert rte: float_to_int: z < 2147483648; */
  /*@ assert rte: float_to_int: -2147483649 < z; */
  __retres = (x + y) - (int)z;
  return __retres;
}

/*@
predicate is_valid_int_range{L}(int *p, int n) =
  \at(0 ≤ n ∧ \valid{L}(p+(0 .. n-1)),L);

*/
/*@ requires is_valid_int_range(p, i); */
int g(int *p, int i)
{
  int __retres;
  if (i >= 1) {
    /*@ assert rte: signed_overflow: -2147483648 ≤ i-1; */
    /*@ assert rte: mem_access: \valid_read(p+(int)(i-1)); */
    __retres = *(p + (i - 1));
    goto return_label;
  }
  else {
    __retres = 0;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires \valid((p+1)+3); */
int h(int *p)
{
  int __retres;
  /*@ assert rte: mem_access: \valid_read(p+3); */
  __retres = *(p + 3);
  return __retres;
}

/*@ requires \valid(p->next);
    requires \valid(p); */
cell *set(cell *p, int v)
{
  cell *__retres;
  /*@ assert rte: mem_access: \valid(&p->val); */
  p->val = v;
  /*@ assert rte: mem_access: \valid_read(&p->next); */
  __retres = p->next;
  return __retres;
}

/*@ requires \valid(cIn.next);
    requires global > 0; */
int next_val(cell cIn)
{
  int __retres;
  /*@ assert rte: mem_access: \valid_read(&(cIn.next)->val); */
  __retres = (cIn.next)->val;
  return __retres;
}

/*@ requires \valid(ptop->next); */
cell *top_set(top *ptop, int v)
{
  cell *tmp;
  /*@ assert rte: mem_access: \valid_read(&ptop->next); */
  /*@ behavior pre_set:
        requires \valid((ptop->next)->next);
        requires \valid(ptop->next);
  */
  tmp = set(ptop->next,v);
  return tmp;
}

/*@ requires \valid(tIn.next); */
int top_next(top tIn)
{
  int tmp;
  /*@ assert rte: mem_access: \valid_read(tIn.next); */
  /*@ behavior pre_next_val:
        requires \valid((tIn.next)->next);
        requires global > 0;
  */
  tmp = next_val(*(tIn.next));
  return tmp;
}

/*@ requires \valid(tab_top);
    requires \valid(&tab_top);
    requires \valid((*(tab_top+i))->next);
 */
cell *tabtop_set(top **tab_top, int i, int v)
{
  cell *tmp;
  /*@ assert rte: mem_access: \valid_read(tab_top+i); */
  /*@ behavior pre_top_set:
        requires \valid((*(tab_top+i))->next); */
  tmp = top_set(*(tab_top + i),v);
  return tmp;
}

int main(void)
{
  int a;
  int b;
  cell c;
  cell *pc;
  top T;
  top tabT[2];
  top *ptabT[3];
  top **pptop;
  other ot;
  void *V;
  int k;
  int l;
  int z;
  int y;
  int w;
  int tab[4];
  int *r;
  int **rr;
  a = 2;
  b = 3;
  c.val = 20;
  c.next = (struct cell *)0;
  { /* sequence */
    ;
    ;
    ;
  }
  ptabT[0] = & T;
  ptabT[1] = & T;
  ptabT[2] = & T;
  ot.c = c;
  k = 1;
  l = 1;
  /*@ behavior pre_f:
        requires 2 > 0;
        requires (int)(2+3) ≢ 0; */
  z = f(2,3,(float)1.0);
  /*@ assert rte: signed_overflow: -2147483648 ≤ b-a; */
  /*@ assert rte: signed_overflow: b-a ≤ 2147483647; */
  /*@ behavior pre_f_2:
        requires (int)(b-a) > 0;
        requires (int)((int)(b-a)+a) ≢ 0;
  */
  y = f(b - a,a,(float)2.0);
  tab[0] = 1;
  tab[1] = 2;
  tab[2] = 3;
  tab[3] = 4;
  /*@ assert rte: signed_overflow: -2147483648 ≤ a+b; */
  /*@ assert rte: signed_overflow: a+b ≤ 2147483647; */
  /*@ behavior pre_f_3:
        requires y > 0;
        requires (int)(y+(int)(a+b)) ≢ 0; */
  z = f(y,a + b,(float)(- 0.0));
  /*@ behavior pre_g:
        requires is_valid_int_range(&z, 1); */
  w = g(& z,1);
  /*@ behavior pre_g_2:
        requires is_valid_int_range(&tab[1], 2); */
  w = g(& tab[1],2);
  /*@ behavior pre_g_3:
        requires is_valid_int_range(&tab[k], l); */
  w = g(& tab[k],l);
  r = tab;
  rr = & r;
  /*@ behavior pre_g_4:
        requires is_valid_int_range(r+2, 0); */
  w = g(r + 2,0);
  /*@ behavior pre_h:
        requires \valid(((int *)tab+1)+3); */
  w = h(tab);
  /*@ behavior pre_h_2:
        requires \valid((r+1)+3); */
  w = h(r);
  /*@ assert rte: mem_access: \valid_read(rr); */
  /*@ behavior pre_h_3:
        requires \valid((*rr+1)+3); */
  w = h(*rr);
  pc = & c;
  c.next = & c;
  /*@ behavior pre_set:
        requires \valid(pc->next);
        requires \valid(pc); */
  set(pc,15);
  /*@ behavior pre_set_2:
        requires \valid(c.next);
        requires \valid(&c); */
  set(& c,10);
  /*@ behavior pre_set_3:
        requires \valid(c.next);
        requires \valid(&c); */
  set(& c,20);
  V = (void *)(& c);
  /*@ behavior pre_set_4:
        requires \valid(((cell *)V)->next);
        requires \valid((cell *)V);
  */
  set((cell *)V,20);
  /*@ behavior pre_next_val:
        requires \valid(c.next);
        requires global > 0; */
  next_val(c);
  /*@ assert rte: mem_access: \valid_read(pc); */
  /*@ behavior pre_next_val_2:
        requires \valid(pc->next);
        requires global > 0;
  */
  next_val(*pc);
  /*@ assert rte: mem_access: \valid_read((cell *)V); */
  /*@ behavior pre_next_val_3:
        requires \valid(((cell *)V)->next);
        requires global > 0;
  */
  next_val(*((cell *)V));
  T.pred = & c;
  T.next = & c;
  tabT[0] = T;
  tabT[1] = T;
  /*@ behavior pre_set_5:
        requires \valid((T.pred)->next);
        requires \valid(T.pred);
  */
  set(T.pred,10);
  /*@ behavior pre_set_6:
        requires \valid((tabT[1].next)->next);
        requires \valid(tabT[1].next);
  */
  set(tabT[1].next,20);
  /*@ assert rte: mem_access: \valid_read(T.next); */
  /*@ behavior pre_next_val_4:
        requires \valid((T.next)->next);
        requires global > 0;
  */
  next_val(*(T.next));
  /*@ assert rte: mem_access: \valid_read(tabT[0].pred); */
  /*@ behavior pre_next_val_5:
        requires \valid((tabT[0].pred)->next);
        requires global > 0;
  */
  next_val(*(tabT[0].pred));
  /*@ assert rte: mem_access: \valid_read(&(ptabT[2])->pred); */
  /*@ behavior pre_set_7:
        requires \valid(((ptabT[2])->pred)->next);
        requires \valid((ptabT[2])->pred);
  */
  set((ptabT[2])->pred,15);
  /*@ behavior pre_set_8:
        requires \valid((tabT[1].pred)->next);
        requires \valid(tabT[1].pred);
  */
  set(tabT[1].pred,10);
  /*@ assert rte: mem_access: \valid_read(&(ptabT[1])->next); */
  /*@ assert rte: mem_access: \valid_read((ptabT[1])->next); */
  /*@ behavior pre_next_val_6:
        requires \valid(((ptabT[1])->next)->next);
        requires global > 0;
  */
  next_val(*((ptabT[1])->next));
  /*@ behavior pre_top_set:
        requires \valid(T.next); */
  top_set(& T,3);
  /*@ behavior pre_top_set_2:
        requires \valid(tabT[1].next); */
  top_set(& tabT[1],2);
  /*@ behavior pre_top_set_3:
        requires \valid((ptabT[1])->next); */
  top_set(ptabT[1],4);
  /*@ behavior pre_top_set_4:
        requires \valid(((top *)c.next)->next); */
  top_set((top *)c.next,5);
  /*@ behavior pre_top_next:
        requires \valid(T.next); */
  top_next(T);
  /*@ assert rte: mem_access: \valid_read(ptabT[0]); */
  /*@ behavior pre_top_next_2:
        requires \valid((ptabT[0])->next); */
  top_next(*(ptabT[0]));
  /*@ behavior pre_tabtop_set:
        requires \valid((top **)ptabT);
        requires \valid(&ptabT);
        requires \valid((*((top **)ptabT+2))->next);
  */
  tabtop_set(ptabT,2,10);
  pptop = ptabT;
  /*@ behavior pre_tabtop_set_2:
        requires \valid(pptop);
        requires \valid(&pptop);
        requires \valid((*(pptop+2))->next);
  */
  tabtop_set(pptop,2,15);
  /*@ behavior pre_tabtop_set_3:
        requires \valid((top **)ptabT);
        requires \valid(&ptabT);
        requires \valid((*((top **)ptabT+1))->next);
  */
  tabtop_set(ptabT,1,20);
  /*@ assert rte: mem_access: \valid_read(&pc->next); */
  /*@ behavior pre_tabtop_set_4:
        requires \valid((top **)pc->next);
        requires \valid((top ***)(&pc->next));
        requires \valid((*((top **)pc->next+1))->next);
  */
  tabtop_set((top **)pc->next,1,10);
  return z;
}


