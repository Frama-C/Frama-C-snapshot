[kernel] Parsing tests/value/pointer_comp.c (with preprocessing)
[value] Analyzing a complete application starting at main
[value] Computing initial state
[value] Initial state computed
[value:initial-state] Values of globals at initialization
  v ∈ [--..--]
  str1[0] ∈ {97}
      [1] ∈ {98}
      [2] ∈ {115}
      [3] ∈ {100}
      [4] ∈ {0}
  str2[0] ∈ {97}
      [1] ∈ {98}
      [2..3] ∈ {100}
      [4] ∈ {0}
  s1 ∈ {0}
  s2[0..7] ∈ {0}
tests/value/pointer_comp.c:37:[value] warning: pointer comparison. assert \pointer_comparable((void *)(&s2[9]), (void *)0);
tests/value/pointer_comp.c:38:[value] warning: pointer comparison.
    assert \pointer_comparable((void *)(&s2[9]), (void *)(&s2[9]));
tests/value/pointer_comp.c:41:[value] warning: pointer comparison.
    assert \pointer_comparable((void *)(&str1), (void *)(&str2));
tests/value/pointer_comp.c:42:[value] warning: pointer comparison. assert \pointer_comparable((void *)(&s1), (void *)(&s2));
tests/value/pointer_comp.c:43:[value] warning: pointer comparison.
    assert \pointer_comparable((void (*)())(&f), (void (*)())(&g));
tests/value/pointer_comp.c:46:[value] warning: pointer comparison. assert \pointer_comparable((void *)(&s1), (void *)0);
tests/value/pointer_comp.c:47:[value] warning: pointer comparison. assert \pointer_comparable((void *)(&s1 + 1), (void *)0);
tests/value/pointer_comp.c:48:[value] warning: pointer comparison. assert \pointer_comparable((void *)(&s2[8]), (void *)0);
tests/value/pointer_comp.c:50:[value] warning: pointer comparison.
    assert \pointer_comparable((void (*)())(&f), (void (*)())0);
tests/value/pointer_comp.c:51:[value] warning: pointer comparison. assert \pointer_comparable((void (*)())p, (void (*)())0);
[value] Recording results for main
[value] done for function main
[value] ====== VALUES COMPUTED ======
[value:final-states] Values at end of function main:
  i ∈ {0; 1}
  p ∈ {{ &f ; &g }}
[from] Computing for function main
[from] Done for function main
[from] ====== DEPENDENCIES COMPUTED ======
    These dependencies hold at termination for the executions that terminate:
[from] Function main:
  NO EFFECTS
[from] ====== END OF DEPENDENCIES ======
[inout] Out (internal) for function main:
      i; p; tmp
[inout] Inputs for function main:
      v
/* Generated by Frama-C */
struct s {
   int x ;
};
extern int v;

char str1[5] = {(char)'a', (char)'b', (char)'s', (char)'d', (char)'\000'};
char str2[5] = {(char)'a', (char)'b', (char)'d', (char)'d', (char)'\000'};
struct s s1;
struct s s2[8];
void f(void);

void g(void);

void main(void)
{
  int i;
  void (*tmp)(void);
  if (v) tmp = & f; else tmp = & g;
  void (*p)(void) = tmp;
  i = & str1 == & str2;
  i = & s1 == (struct s *)0;
  i = & s1 + 1 == (struct s *)0;
  i = & s2[2] == & s2[4];
  i = & s2[8] == (struct s *)0;
  i = & f == (void (*)(void))0;
  i = (void *)(& s1) == (void *)(& s2);
  i = & f == & g;
  i = p == (void (*)(void))0;
  i = & s2[2] < & s2[4];
  /*@ assert
      Value: ptr_comparison: \pointer_comparable((void *)(&s2[9]), (void *)0);
  */
  i = & s2[9] == (struct s *)0;
  /*@ assert
      Value: ptr_comparison:
        \pointer_comparable((void *)(&s2[9]), (void *)(&s2[9]));
  */
  i = & s2[9] == & s2[9];
  /*@ assert
      Value: ptr_comparison:
        \pointer_comparable((void *)(&str1), (void *)(&str2));
  */
  i = & str1 < & str2;
  /*@ assert
      Value: ptr_comparison:
        \pointer_comparable((void *)(&s1), (void *)(&s2));
  */
  i = (void *)(& s1) < (void *)(& s2);
  /*@ assert
      Value: ptr_comparison:
        \pointer_comparable((void (*)())(&f), (void (*)())(&g));
  */
  i = & f < & g;
  /*@ assert
      Value: ptr_comparison: \pointer_comparable((void *)(&s1), (void *)0);
  */
  i = & s1 > (struct s *)0;
  /*@ assert
      Value: ptr_comparison:
        \pointer_comparable((void *)(&s1 + 1), (void *)0);
  */
  i = & s1 + 1 > (struct s *)0;
  /*@ assert
      Value: ptr_comparison: \pointer_comparable((void *)(&s2[8]), (void *)0);
  */
  i = & s2[8] > (struct s *)0;
  i = & f == (void (*)(void))0;
  /*@ assert
      Value: ptr_comparison:
        \pointer_comparable((void (*)())(&f), (void (*)())0);
  */
  i = & f > (void (*)(void))0;
  /*@ assert
      Value: ptr_comparison:
        \pointer_comparable((void (*)())p, (void (*)())0);
  */
  i = p > (void (*)(void))0;
  return;
}


