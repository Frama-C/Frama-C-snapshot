[kernel] Parsing tests/value/pointer_comp.c (with preprocessing)
[eva] Analyzing a complete application starting at main
[eva] Computing initial state
[eva] Initial state computed
[eva:initial-state] Values of globals at initialization
  v ∈ [--..--]
  str1[0] ∈ {97}
      [1] ∈ {98}
      [2] ∈ {115}
      [3] ∈ {100}
      [4] ∈ {0}
  str2[0] ∈ {97}
      [1] ∈ {98}
      [2..3] ∈ {100}
      [4] ∈ {0}
  s1 ∈ {0}
  s2[0..7] ∈ {0}
[eva:alarm] tests/value/pointer_comp.c:37: Warning: 
  pointer comparison. assert \pointer_comparable((void *)(&s2[9]), (void *)0);
[eva:alarm] tests/value/pointer_comp.c:38: Warning: 
  pointer comparison.
  assert \pointer_comparable((void *)(&s2[9]), (void *)(&s2[9]));
[eva:alarm] tests/value/pointer_comp.c:41: Warning: 
  pointer comparison.
  assert \pointer_comparable((void *)(&str1), (void *)(&str2));
[eva:alarm] tests/value/pointer_comp.c:42: Warning: 
  pointer comparison. assert \pointer_comparable((void *)(&s1), (void *)(&s2));
[eva:alarm] tests/value/pointer_comp.c:43: Warning: 
  pointer comparison.
  assert \pointer_comparable((void (*)())(&f), (void (*)())(&g));
[eva:alarm] tests/value/pointer_comp.c:46: Warning: 
  pointer comparison. assert \pointer_comparable((void *)(&s1), (void *)0);
[eva:alarm] tests/value/pointer_comp.c:47: Warning: 
  pointer comparison. assert \pointer_comparable((void *)(&s1 + 1), (void *)0);
[eva:alarm] tests/value/pointer_comp.c:48: Warning: 
  pointer comparison. assert \pointer_comparable((void *)(&s2[8]), (void *)0);
[eva:alarm] tests/value/pointer_comp.c:50: Warning: 
  pointer comparison.
  assert \pointer_comparable((void (*)())(&f), (void (*)())0);
[eva:alarm] tests/value/pointer_comp.c:51: Warning: 
  pointer comparison. assert \pointer_comparable((void (*)())p, (void (*)())0);
[eva] Recording results for main
[eva] done for function main
[eva] ====== VALUES COMPUTED ======
[eva:final-states] Values at end of function main:
  i ∈ {0; 1}
  p ∈ {{ &f ; &g }}
[from] Computing for function main
[from] Done for function main
[from] ====== DEPENDENCIES COMPUTED ======
  These dependencies hold at termination for the executions that terminate:
[from] Function main:
  NO EFFECTS
[from] ====== END OF DEPENDENCIES ======
[inout] Out (internal) for function main:
    i; p; tmp
[inout] Inputs for function main:
    v
/* Generated by Frama-C */
struct s {
   int x ;
};
extern int v;

char str1[5] = {(char)'a', (char)'b', (char)'s', (char)'d', (char)'\000'};
char str2[5] = {(char)'a', (char)'b', (char)'d', (char)'d', (char)'\000'};
struct s s1;
struct s s2[8];
void f(void);

void g(void);

void main(void)
{
  int i;
  void (*tmp)(void);
  if (v) tmp = & f; else tmp = & g;
  void (*p)(void) = tmp;
  i = & str1 == & str2;
  i = & s1 == (struct s *)0;
  i = & s1 + 1 == (struct s *)0;
  i = & s2[2] == & s2[4];
  i = & s2[8] == (struct s *)0;
  i = & f == (void (*)(void))0;
  i = (void *)(& s1) == (void *)(& s2);
  i = & f == & g;
  i = p == (void (*)(void))0;
  i = & s2[2] < & s2[4];
  /*@ assert
      Eva: ptr_comparison: \pointer_comparable((void *)(&s2[9]), (void *)0);
  */
  i = & s2[9] == (struct s *)0;
  /*@ assert
      Eva: ptr_comparison:
        \pointer_comparable((void *)(&s2[9]), (void *)(&s2[9]));
  */
  i = & s2[9] == & s2[9];
  /*@ assert
      Eva: ptr_comparison:
        \pointer_comparable((void *)(&str1), (void *)(&str2));
  */
  i = & str1 < & str2;
  /*@ assert
      Eva: ptr_comparison: \pointer_comparable((void *)(&s1), (void *)(&s2));
  */
  i = (void *)(& s1) < (void *)(& s2);
  /*@ assert
      Eva: ptr_comparison:
        \pointer_comparable((void (*)())(&f), (void (*)())(&g));
  */
  i = & f < & g;
  /*@ assert
      Eva: ptr_comparison: \pointer_comparable((void *)(&s1), (void *)0);
  */
  i = & s1 > (struct s *)0;
  /*@ assert
      Eva: ptr_comparison: \pointer_comparable((void *)(&s1 + 1), (void *)0);
  */
  i = & s1 + 1 > (struct s *)0;
  /*@ assert
      Eva: ptr_comparison: \pointer_comparable((void *)(&s2[8]), (void *)0);
  */
  i = & s2[8] > (struct s *)0;
  i = & f == (void (*)(void))0;
  /*@ assert
      Eva: ptr_comparison:
        \pointer_comparable((void (*)())(&f), (void (*)())0);
  */
  i = & f > (void (*)(void))0;
  /*@ assert
      Eva: ptr_comparison: \pointer_comparable((void (*)())p, (void (*)())0);
  */
  i = p > (void (*)(void))0;
  return;
}


