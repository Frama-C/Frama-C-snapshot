[kernel] Parsing tests/value/volatile2.i (no preprocessing)
[value] Analyzing a complete application starting at main
[value] Computing initial state
[value] Initial state computed
[value:initial-state] Values of globals at initialization
  t[0..9] ∈ [--..--]
  u ∈ [--..--]
  pu ∈ {{ &u }}
  s ∈ {0}
  ps ∈ {{ &s }}
  v ∈ [--..--]
  BITF ∈ [--..--]
  S9 ∈ [--..--]
  u9[0..9] ∈ [--..--]
[value] computing for function main1 <- main.
  Called from tests/value/volatile2.i:136.
[value:alarm] tests/value/volatile2.i:23: Warning: 
  signed overflow. assert (int)c << 8 ≤ 32767;
[value:alarm] tests/value/volatile2.i:24: Warning: 
  signed overflow. assert (int)*p << 8 ≤ 32767;
[value:alarm] tests/value/volatile2.i:25: Warning: 
  signed overflow. assert (int)t[1] << 8 ≤ 32767;
[value:alarm] tests/value/volatile2.i:26: Warning: 
  signed overflow. assert (int)u.f1 << 8 ≤ 32767;
[value] Recording results for main1
[value] Done for function main1
[value] computing for function main2 <- main.
  Called from tests/value/volatile2.i:137.
[value] Recording results for main2
[value] Done for function main2
[value] computing for function main3 <- main.
  Called from tests/value/volatile2.i:138.
[value:alarm] tests/value/volatile2.i:47: Warning: 
  assertion got status invalid (stopping propagation).
[value] tests/value/volatile2.i:52: assertion got status valid.
[value:alarm] tests/value/volatile2.i:55: Warning: assertion got status unknown.
[value:alarm] tests/value/volatile2.i:56: Warning: assertion got status unknown.
[value] tests/value/volatile2.i:59: assertion got status valid.
[value] Recording results for main3
[value] Done for function main3
[value] computing for function main4 <- main.
  Called from tests/value/volatile2.i:139.
[value] Recording results for main4
[value] Done for function main4
[value] computing for function main5 <- main.
  Called from tests/value/volatile2.i:140.
[value:alarm] tests/value/volatile2.i:76: Warning: 
  signed overflow. assert i + 1 ≤ 32767;
[value:alarm] tests/value/volatile2.i:76: Warning: 
  signed overflow. assert j + 1 ≤ 32767;
[value:alarm] tests/value/volatile2.i:76: Warning: 
  signed overflow.
  assert -32768 ≤ tmp + tmp_0;
  (tmp from i++, tmp_0 from j++)
[value:alarm] tests/value/volatile2.i:76: Warning: 
  signed overflow. assert tmp + tmp_0 ≤ 32767;
                   (tmp from i++, tmp_0 from j++)
[value:alarm] tests/value/volatile2.i:78: Warning: 
  signed overflow. assert i + 1 ≤ 32767;
[value:alarm] tests/value/volatile2.i:78: Warning: 
  signed overflow. assert j + 1 ≤ 32767;
[value:alarm] tests/value/volatile2.i:78: Warning: 
  signed overflow. assert -32768 ≤ i + j;
[value:alarm] tests/value/volatile2.i:78: Warning: 
  signed overflow. assert i + j ≤ 32767;
[value] tests/value/volatile2.i:80: 
  Frama_C_dump_each:
  # Cvalue domain:
  t[0..9] ∈ [--..--]
  u ∈ [--..--]
  pu ∈ {{ &u }}
  s ∈ {0}
  ps ∈ {{ &s }}
  v ∈ [--..--]
  i ∈ [--..--]
  j ∈ [--..--]
  k ∈ [--..--]
  tmp ∈ [--..--]
  tmp_0 ∈ [--..--]
  l ∈ [--..--]
  BITF ∈ [--..--]
  S9 ∈ [--..--]
  u9[0..9] ∈ [--..--]
  ==END OF DUMP==
[value] Recording results for main5
[value] Done for function main5
[value] computing for function main6 <- main.
  Called from tests/value/volatile2.i:141.
[value] Recording results for main6
[value] Done for function main6
[value] computing for function main7 <- main.
  Called from tests/value/volatile2.i:142.
[value] Recording results for main7
[value] Done for function main7
[value] computing for function main8 <- main.
  Called from tests/value/volatile2.i:143.
[value] tests/value/volatile2.i:119: 
  Frama_C_show_each: [--..--], [--..--], [--..--], [--..--], [--..--]
[value] Recording results for main8
[value] Done for function main8
[value] computing for function main9 <- main.
  Called from tests/value/volatile2.i:144.
[value:alarm] tests/value/volatile2.i:129: Warning: 
  accessing out of bounds index. assert 0 ≤ S9.i1;
[value:alarm] tests/value/volatile2.i:129: Warning: 
  accessing out of bounds index. assert S9.i1 < 10;
[value:alarm] tests/value/volatile2.i:130: Warning: 
  accessing out of bounds index. assert 0 ≤ S9.i1;
[value:alarm] tests/value/volatile2.i:130: Warning: 
  accessing out of bounds index. assert S9.i1 < 10;
[value:alarm] tests/value/volatile2.i:131: Warning: 
  accessing out of bounds index. assert 0 ≤ u9[1];
[value:alarm] tests/value/volatile2.i:131: Warning: 
  accessing out of bounds index. assert u9[1] < 10;
[value:alarm] tests/value/volatile2.i:132: Warning: 
  accessing out of bounds index. assert 0 ≤ u9[1];
[value:alarm] tests/value/volatile2.i:132: Warning: 
  accessing out of bounds index. assert u9[1] < 10;
[value] Recording results for main9
[value] Done for function main9
[value] Recording results for main
[value] done for function main
[value] ====== VALUES COMPUTED ======
[value:final-states] Values at end of function main1:
  c ∈ [--..--]
  x ∈ {1}
  p ∈ {{ (unsigned char volatile *)&x }}
  i ∈ [0..32767]
  j ∈ [0..32767]
  k ∈ [0..32767]
  l ∈ [0..32767]
[value:final-states] Values at end of function main2:
  i ∈ [-128..127]
  j ∈ [0..255]
  k ∈ [0..255]
[value:final-states] Values at end of function main3:
  
[value:final-states] Values at end of function main4:
  p1 ∈ {{ &i }}
  p2 ∈ {{ &i + [--..--] }}
[value:final-states] Values at end of function main5:
  i ∈ [--..--]
  j ∈ [--..--]
  k ∈ [--..--]
  l ∈ [--..--]
[value:final-states] Values at end of function main6:
  i ∈ {1}
  j ∈ {1}
[value:final-states] Values at end of function main7:
  i ∈ {-3; -2; -1; 0; 1; 2; 3; 4}
  k ∈ [1..16]
[value:final-states] Values at end of function main8:
  a ∈ [--..--]
  b ∈ [--..--]
  c ∈ [--..--]
  d ∈ [--..--]
  e ∈ [--..--]
[value:final-states] Values at end of function main9:
  t9[0..9] ∈ {1; 2; 3; 4} or UNINITIALIZED
[value:final-states] Values at end of function main:
  
/* Generated by Frama-C */
struct u {
   unsigned char f1 ;
   unsigned char f2 ;
};
struct s {
   char i1 ;
   char i2 ;
};
struct bitf {
   int i : 3 ;
   unsigned int j : 4 ;
};
struct __anonstruct_S_1 {
   int field ;
};
typedef struct __anonstruct_S_1 S;
typedef S volatile vS;
struct __anonstruct_vS2_2 {
   int field ;
};
typedef struct __anonstruct_vS2_2 volatile vS2;
union __anonunion_U_3 {
   int field ;
};
typedef union __anonunion_U_3 U;
typedef U volatile vU;
struct __anonstruct_S9_4 {
   int volatile i1 ;
   int i2 ;
};
unsigned char volatile t[10];
struct u volatile u;
struct u *pu = (struct u *)(& u);
void main1(void)
{
  unsigned char volatile c = (unsigned char)1;
  int x = 1;
  unsigned char volatile *p = (unsigned char volatile *)(& x);
  /*@ assert Value: signed_overflow: (int)c << 8 ≤ 32767; */
  unsigned int i = (unsigned int)(((int)c << 8) + (int)c);
  /*@ assert Value: signed_overflow: (int)*p << 8 ≤ 32767; */
  unsigned int j = (unsigned int)(((int)*p << 8) + (int)*p);
  /*@ assert Value: signed_overflow: (int)t[1] << 8 ≤ 32767; */
  unsigned int k = (unsigned int)(((int)t[1] << 8) + (int)t[2]);
  /*@ assert Value: signed_overflow: (int)u.f1 << 8 ≤ 32767; */
  unsigned int l = (unsigned int)(((int)u.f1 << 8) + (int)u.f2);
  return;
}

struct s s;
struct s volatile *ps = (struct s volatile *)(& s);
void main2(void)
{
  int i = (int)ps->i1;
  int j = (int)u.f1;
  int k = (int)t[1];
  return;
}

int volatile v;
void main3(void)
{
  if (v) 
    /*@ assert \false; */ ;
  if (v) 
    /*@ assert \true; */ ;
  /*@ assert v ≡ 0; */ ;
  /*@ assert v ≡ 0; */ ;
  if (v) 
    /*@ assert \true; */ ;
  return;
}

void main4(void)
{
  int volatile i;
  int volatile *p1 = & i;
  int volatile * volatile p2 = & i;
  return;
}

/*@ assigns \result;
    assigns \result \from \nothing; */
extern int ( /* missing proto */ Frama_C_dump_each)();

void main5(void)
{
  int tmp;
  int tmp_0;
  int volatile i = 0;
  int volatile j = 0;
  tmp = i;
  /*@ assert Value: signed_overflow: i + 1 ≤ 32767; */
  i ++;
  tmp_0 = j;
  /*@ assert Value: signed_overflow: j + 1 ≤ 32767; */
  j ++;
  /*@ assert Value: signed_overflow: -32768 ≤ tmp + tmp_0; */
  /*@ assert Value: signed_overflow: tmp + tmp_0 ≤ 32767; */
  int k = tmp + tmp_0;
  /*@ assert Value: signed_overflow: i + 1 ≤ 32767; */
  i ++;
  /*@ assert Value: signed_overflow: j + 1 ≤ 32767; */
  j ++;
  /*@ assert Value: signed_overflow: -32768 ≤ i + j; */
  /*@ assert Value: signed_overflow: i + j ≤ 32767; */
  int l = i + j;
  Frama_C_dump_each();
  return;
}

void main6(void)
{
  int i = 1;
  int j = i;
  return;
}

struct bitf volatile BITF;
void main7(void)
{
  int i = (int)BITF.i + 1;
  int k = (int)BITF.j + 1;
  return;
}

/*@ assigns \result;
    assigns \result \from \nothing; */
extern int ( /* missing proto */ Frama_C_show_each)();

void main8(void)
{
  S volatile a = {.field = 0};
  vS b = {.field = 0};
  vS2 c = {.field = 0};
  U volatile d = {.field = 0};
  vU e = {.field = 0};
  Frama_C_show_each(a,b,c,d,e);
  return;
}

extern struct __anonstruct_S9_4 S9;

int volatile u9[10];
void main9(void)
{
  int t9[10];
  /*@ assert Value: index_bound: 0 ≤ S9.i1; */
  /*@ assert Value: index_bound: S9.i1 < 10; */
  t9[S9.i1] = 1;
  /*@ assert Value: index_bound: 0 ≤ S9.i1; */
  /*@ assert Value: index_bound: S9.i1 < 10; */
  t9[S9.i1] = 2;
  /*@ assert Value: index_bound: 0 ≤ u9[1]; */
  /*@ assert Value: index_bound: u9[1] < 10; */
  t9[u9[1]] = 3;
  /*@ assert Value: index_bound: 0 ≤ u9[1]; */
  /*@ assert Value: index_bound: u9[1] < 10; */
  t9[u9[1]] = 4;
  return;
}

void main(void)
{
  main1();
  main2();
  main3();
  main4();
  main5();
  main6();
  main7();
  main8();
  main9();
  return;
}


