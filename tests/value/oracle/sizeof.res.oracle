[kernel] Parsing tests/value/sizeof.i (no preprocessing)
[value] Analyzing a complete application starting at main
[value] Computing initial state
[value] Initial state computed
[value:initial-state] Values of globals at initialization
  sz_str ∈ {0}
  sz_typ ∈ {0}
  align_str ∈ {0}
  align_typ ∈ {0}
  s1 ∈ {0}
  i ∈ [--..--]
[value] computing for function main1 <- main.
    Called from tests/value/sizeof.i:38.
tests/value/sizeof.i:10:[value] assertion got status valid.
tests/value/sizeof.i:14:[value] assertion got status valid.
tests/value/sizeof.i:17:[value] assertion got status valid.
[value] Recording results for main1
[value] Done for function main1
[value] computing for function main2 <- main.
    Called from tests/value/sizeof.i:39.
tests/value/sizeof.i:32:[value] Assigning imprecise value to p.
    The imprecision originates from Arithmetic {tests/value/sizeof.i:32}
tests/value/sizeof.i:33:[value] warning: accessing out of bounds index.
    assert (unsigned int)(sizeof(s1.t) - (unsigned int)i) < 10;
tests/value/sizeof.i:33:[value] warning: out of bounds write.
    assert \valid(&p->t[(unsigned int)(sizeof(s1.t) - (unsigned int)i)]);
tests/value/sizeof.i:34:[value] warning: accessing out of bounds index.
    assert (unsigned int)(sizeof(s1.t) - (unsigned int)i) < 10;
tests/value/sizeof.i:34:[value] warning: out of bounds write.
    assert \valid(&p->t[(unsigned int)(sizeof(s1.t) - (unsigned int)i)]);
[value] Recording results for main2
[value] Done for function main2
[value] Recording results for main
[value] done for function main
[value] ====== VALUES COMPUTED ======
[value:final-states] Values at end of function main1:
  sz_str ∈ {4}
  sz_typ ∈ {1}
  align_str ∈ {1}
  align_typ ∈ {4}
[value:final-states] Values at end of function main2:
  s1 ∈ [--..--]
  p ∈ {{ &s1 + [-36..36] }}
[value:final-states] Values at end of function main:
  sz_str ∈ {4}
  sz_typ ∈ {1}
  align_str ∈ {1}
  align_typ ∈ {4}
  s1 ∈ [--..--]
[from] Computing for function main1
[from] Done for function main1
[from] Computing for function main2
[from] Done for function main2
[from] Computing for function main
[from] Done for function main
[from] ====== DEPENDENCIES COMPUTED ======
    These dependencies hold at termination for the executions that terminate:
[from] Function main1:
  sz_str FROM \nothing
  sz_typ FROM \nothing
  align_str FROM \nothing
  align_typ FROM \nothing
[from] Function main2:
  s1 FROM i (and SELF)
[from] Function main:
  sz_str FROM \nothing
  sz_typ FROM \nothing
  align_str FROM \nothing
  align_typ FROM \nothing
  s1 FROM i (and SELF)
[from] ====== END OF DEPENDENCIES ======
[inout] Out (internal) for function main1:
      sz_str; sz_typ; align_str; align_typ
[inout] Inputs for function main1:
      \nothing
[inout] Out (internal) for function main2:
      s1; p
[inout] Inputs for function main2:
      i
[inout] Out (internal) for function main:
      sz_str; sz_typ; align_str; align_typ; s1
[inout] Inputs for function main:
      i
/* Generated by Frama-C */
struct s {
   int t[10] ;
};
int sz_str;
int sz_typ;
int align_str;
int align_typ;
void main1(void)
{
  sz_str = (int)sizeof("ONE");
  /*@ assert sz_str ≡ sizeof("ONE"); */ ;
  align_str = (int)__alignof__("FOO");
  sz_typ = (int)sizeof(char);
  /*@ assert sz_typ ≡ sizeof(char); */ ;
  align_typ = (int)__alignof__(char *);
  /*@ assert sizeof("BLA") ≢ sizeof("FOOBAR"); */ ;
  return;
}

struct s s1;
int volatile i;
void main2(void)
{
  struct s *p = & s1 + (int)(& s1);
  /*@ assert
      Value: index_bound: (unsigned int)(sizeof(s1.t) - (unsigned int)i) < 10;
  */
  /*@ assert
      Value: mem_access:
        \valid(&p->t[(unsigned int)(sizeof(s1.t) - (unsigned int)i)]);
  */
  p->t[sizeof(s1.t) - (unsigned int)i] = 1;
  /*@ assert
      Value: index_bound: (unsigned int)(sizeof(s1.t) - (unsigned int)i) < 10;
  */
  /*@ assert
      Value: mem_access:
        \valid(&p->t[(unsigned int)(sizeof(s1.t) - (unsigned int)i)]);
  */
  p->t[sizeof(s1.t) - (unsigned int)i] = 2;
  return;
}

void main(void)
{
  main1();
  main2();
  return;
}


