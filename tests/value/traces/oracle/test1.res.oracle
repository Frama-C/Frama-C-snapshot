[kernel] Parsing tests/value/traces/test1.c (with preprocessing)
[eva] Analyzing a complete application starting at main
[eva] Computing initial state
[eva] Initial state computed
[eva:initial-state] Values of globals at initialization
  entropy_source ∈ [--..--]
  g ∈ {42}
[eva] Recording results for main
[eva] done for function main
[eva] ====== VALUES COMPUTED ======
[eva:final-states] Values at end of function main:
  g ∈ {5; 45}
  tmp ∈ {5; 45}
[eva:d-traces] Trace domains:
 start: 0; globals = g, entropy_source; main_formals = c;
 {[ 0 -> initialize variable: entropy_source -> 1
    1 -> initialize variable using type Library_Global
entropy_source -> 2
    2 -> initialize variable: g -> 3
    3 -> Assign: g = 42 -> 4
    4 -> initialize variable using type Main_Formal
c -> 5
    5 -> EnterScope: tmp -> 6
    6 -> Assign: tmp = 0 -> 7
    7 -> Assume: c true -> 8; Assume: c false -> 10
    8 -> Assign: tmp = g -> 9
    9 -> EnterScope: i -> 12
    10 -> Assign: tmp = 2 -> 11
    11 -> EnterScope: i -> 15
    12 -> initialize variable: i -> 13
    13 -> Assign: i = 0 -> 14
    14 -> enter_loop -> 19
    15 -> initialize variable: i -> 16
    16 -> Assign: i = 0 -> 17
    17 -> enter_loop -> 18
    18 -> Assume: i < 3 true -> 20
    19 -> Assume: i < 3 true -> 21
    20 -> Assign: tmp = tmp + 1 -> 22
    21 -> Assign: tmp = tmp + 1 -> 23
    22 -> Assign: i = i + 1 -> 24
    23 -> Assign: i = i + 1 -> 25
    24 -> Assume: i < 3 true -> 27
    25 -> Assume: i < 3 true -> 26
    26 -> Assign: tmp = tmp + 1 -> 28
    27 -> Assign: tmp = tmp + 1 -> 29
    28 -> Assign: i = i + 1 -> 30
    29 -> Assign: i = i + 1 -> 31
    30 -> Assume: i < 3 true -> 33
    31 -> Assume: i < 3 true -> 32
    32 -> Assign: tmp = tmp + 1 -> 34
    33 -> Assign: tmp = tmp + 1 -> 35
    34 -> Assign: i = i + 1 -> 36
    35 -> Assign: i = i + 1 -> 37
    36 -> Assume: i < 3 false -> 39
    37 -> Assume: i < 3 false -> 38
    38 -> LeaveScope: i -> 41
    39 -> LeaveScope: i -> 40
    40 -> LeaveScope: i -> 42
    41 -> LeaveScope: i -> 43
    42 -> Assign: g = tmp -> 44
    43 -> Assign: g = tmp -> 45
    44 -> EnterScope: \result<main> -> 46
    45 -> EnterScope: \result<main> -> 48
    46 -> Assign: \result<main> = tmp -> 47
    47 -> join -> 50
    48 -> Assign: \result<main> = tmp -> 49
    49 -> join -> 50 ]} at 50
[from] Computing for function main
[from] Done for function main
[from] ====== DEPENDENCIES COMPUTED ======
  These dependencies hold at termination for the executions that terminate:
[from] Function main:
  g FROM g; c
  \result FROM g; c
[from] ====== END OF DEPENDENCIES ======
[inout] Out (internal) for function main:
    g; tmp; i
[inout] Inputs for function main:
    g
[eva] Analyzing a complete application starting at main
[eva] Computing initial state
[eva] Initial state computed
[eva:initial-state] Values of globals at initialization
  entropy_source ∈ [--..--]
  g ∈ {42}
[eva] done for function main
[eva] ====== VALUES COMPUTED ======
[eva:final-states] Values at end of function main:
  g ∈ {5; 45}
  __traces_domain_return ∈ {5; 45}
/* Generated by Frama-C */
extern int volatile entropy_source;

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, entropy_source;
    assigns \result \from min, max, entropy_source;
    assigns entropy_source \from entropy_source;
 */
extern int interval(int min, int max);

int g = 42;
int main(int c)
{
  int __traces_domain_return;
  g = 42;
  {
    int tmp;
    tmp = 0;
    if (c) {
      tmp = g;
      {
        int i;
        i = 0;
        /*@ assert i < 3;  */
        tmp ++;
        i ++;
        /*@ assert i < 3;  */
        tmp ++;
        i ++;
        /*@ assert i < 3;  */
        tmp ++;
        i ++;
        /*@ assert ¬(i < 3);  */
        g = tmp;
        {
          int _result_main_;
          _result_main_ = tmp;
          __traces_domain_return = tmp;
        }
      }
    }
    else {
      tmp = 2;
      {
        int i;
        i = 0;
        /*@ assert i < 3;  */
        tmp ++;
        i ++;
        /*@ assert i < 3;  */
        tmp ++;
        i ++;
        /*@ assert i < 3;  */
        tmp ++;
        i ++;
        /*@ assert ¬(i < 3);  */
        g = tmp;
        {
          int _result_main_;
          _result_main_ = tmp;
          __traces_domain_return = tmp;
        }
      }
    }
  }
  return __traces_domain_return;
}


