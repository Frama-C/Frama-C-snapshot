[kernel] Parsing tests/value/traces/test2.i (no preprocessing)
[eva] Analyzing a complete application starting at main
[eva] Computing initial state
[eva] Initial state computed
[eva:initial-state] Values of globals at initialization
  
[eva] computing for function loop <- main.
  Called from tests/value/traces/test2.i:18.
[eva] Recording results for loop
[eva] Done for function loop
[eva] computing for function loop <- main.
  Called from tests/value/traces/test2.i:18.
[eva] Recording results for loop
[eva] Done for function loop
[eva] Recording results for main
[eva] done for function main
[eva] ====== VALUES COMPUTED ======
[eva:final-states] Values at end of function loop:
  j ∈ {4; 5}
[eva:final-states] Values at end of function main:
  tmp ∈ {4; 5}
[eva:d-traces] Trace domains:
 start: 0; globals = ; main_formals = c;
 {[ 0 -> initialize variable using type Main_Formal
c -> 1
    1 -> EnterScope: tmp -> 2
    2 -> Assign: tmp = 0 -> 3
    3 -> Assume: c true -> 4; Assume: c false -> 6
    4 -> Assign: tmp = 1 -> 5
    5 -> start_call: loop (true) -> 8
    6 -> Assign: tmp = 2 -> 7
    7 -> start_call: loop (true) -> 40
    8 -> EnterScope: j -> 9
    9 -> Assign: j = tmp -> 10
    10 -> EnterScope: i -> 11
    11 -> initialize variable: i -> 12
    12 -> Assign: i = 0 -> 13
    13 -> enter_loop -> 14
    14 -> Assume: i < 3 true -> 15
    15 -> Assign: j = j + 1 -> 16
    16 -> Assign: i = i + 1 -> 17
    17 -> Assume: i < 3 true -> 18
    18 -> Assign: j = j + 1 -> 19
    19 -> Assign: i = i + 1 -> 20
    20 -> Assume: i < 3 true -> 21
    21 -> Assign: j = j + 1 -> 22
    22 -> Assign: i = i + 1 -> 23
    23 -> Assume: i < 3 false -> 24
    24 -> LeaveScope: i -> 25
    25 -> LeaveScope: i -> 26
    26 -> EnterScope: \result<loop> -> 27
    27 -> Assign: \result<loop> = j -> 28
    28 -> LeaveScope: j -> 36
    36 -> finalize_call: loop -> 37
    37 -> Assign: tmp = \result<loop> -> 38
    38 -> LeaveScope: \result<loop> -> 39
    39 -> EnterScope: \result<main> -> 80
    40 -> EnterScope: j -> 41
    41 -> Assign: j = tmp -> 42
    42 -> EnterScope: i -> 44
    44 -> initialize variable: i -> 45
    45 -> Assign: i = 0 -> 46
    46 -> enter_loop -> 47
    47 -> Assume: i < 3 true -> 48
    48 -> Assign: j = j + 1 -> 49
    49 -> Assign: i = i + 1 -> 50
    50 -> Assume: i < 3 true -> 51
    51 -> Assign: j = j + 1 -> 52
    52 -> Assign: i = i + 1 -> 53
    53 -> Assume: i < 3 true -> 54
    54 -> Assign: j = j + 1 -> 55
    55 -> Assign: i = i + 1 -> 56
    56 -> Assume: i < 3 false -> 57
    57 -> LeaveScope: i -> 58
    58 -> LeaveScope: i -> 59
    59 -> EnterScope: \result<loop> -> 60
    60 -> Assign: \result<loop> = j -> 61
    61 -> LeaveScope: j -> 76
    76 -> finalize_call: loop -> 77
    77 -> Assign: tmp = \result<loop> -> 78
    78 -> LeaveScope: \result<loop> -> 79
    79 -> EnterScope: \result<main> -> 82
    80 -> Assign: \result<main> = tmp -> 81
    81 -> join -> 84
    82 -> Assign: \result<main> = tmp -> 83
    83 -> join -> 84 ]} at 84
[from] Computing for function loop
[from] Done for function loop
[from] Computing for function main
[from] Done for function main
[from] ====== DEPENDENCIES COMPUTED ======
  These dependencies hold at termination for the executions that terminate:
[from] Function loop:
  \result FROM j
[from] Function main:
  \result FROM c
[from] ====== END OF DEPENDENCIES ======
[inout] Out (internal) for function loop:
    j; i
[inout] Inputs for function loop:
    \nothing
[inout] Out (internal) for function main:
    tmp
[inout] Inputs for function main:
    \nothing
[eva] Analyzing a complete application starting at main
[eva] Computing initial state
[eva] Initial state computed
[eva:initial-state] Values of globals at initialization
  
[eva] done for function main
[eva] ====== VALUES COMPUTED ======
[eva:final-states] Values at end of function main:
  __traces_domain_return ∈ {4; 5}
/* Generated by Frama-C */
int main(int c)
{
  int __traces_domain_return;
  {
    int tmp;
    tmp = 0;
    if (c) {
      tmp = 1;
      {
        int j;
        j = tmp;
        {
          int i;
          i = 0;
          /*@ assert i < 3;  */
          j ++;
          i ++;
          /*@ assert i < 3;  */
          j ++;
          i ++;
          /*@ assert i < 3;  */
          j ++;
          i ++;
          /*@ assert ¬(i < 3);  */
          {
            int _result_loop_;
            _result_loop_ = j;
            tmp = _result_loop_;
            {
              int _result_main_;
              _result_main_ = tmp;
              __traces_domain_return = tmp;
            }
          }
        }
      }
    }
    else {
      tmp = 2;
      {
        int j;
        j = tmp;
        {
          int i;
          i = 0;
          /*@ assert i < 3;  */
          j ++;
          i ++;
          /*@ assert i < 3;  */
          j ++;
          i ++;
          /*@ assert i < 3;  */
          j ++;
          i ++;
          /*@ assert ¬(i < 3);  */
          {
            int _result_loop_;
            _result_loop_ = j;
            tmp = _result_loop_;
            {
              int _result_main_;
              _result_main_ = tmp;
              __traces_domain_return = tmp;
            }
          }
        }
      }
    }
  }
  return __traces_domain_return;
}


