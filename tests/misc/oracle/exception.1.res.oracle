[kernel] Parsing share/libc/__fc_builtin_for_normalization.i (no preprocessing)
[kernel] Parsing tests/misc/exception.i (no preprocessing)
/* Generated by Frama-C */
struct my_exn {
   int e ;
};
struct my_exn2 {
   char c ;
};
enum __fc_exn_enum {
    __fc_exn_kind___fc_Smy_exn2 = 3,
    __fc_exn_kind___fc_Smy_exn = 2,
    __fc_exn_kind___fc_pi = 1,
    __fc_exn_kind___fc_i = 0
};
union __fc_exn_union {
   struct my_exn2 __fc_Smy_exn2 ;
   struct my_exn __fc_Smy_exn ;
   int *__fc_pi ;
   int __fc_i ;
};
struct __fc_exn_struct {
   int exn_uncaught ;
   enum __fc_exn_enum exn_kind ;
   union __fc_exn_union exn_obj ;
};
struct __fc_exn_struct __fc_exn =
  {.exn_uncaught = 0,
   .exn_kind = 0,
   .exn_obj = {.__fc_Smy_exn2 = {.c = (char)0}}};
struct my_exn foo;
struct my_exn2 bar;
int x = 42;
int f1(int c)
{
  int __retres;
  if (c) {
    struct my_exn exn;
    exn.e = 0;
    __fc_exn.exn_uncaught = 1;
    __fc_exn.exn_kind = __fc_exn_kind___fc_Smy_exn;
    __fc_exn.exn_obj.__fc_Smy_exn = exn;
    __retres = 0;
    goto return_label;
  }
  else {
    __retres = c;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ ensures __fc_exn.exn_uncaught ≡ 0 ⇒ \result ≡ \old(c)+1; */
int f2(int c)
{
  int __retres;
  if (c < 50) {
    int exn;
    exn = 0;
    __fc_exn.exn_uncaught = 1;
    __fc_exn.exn_kind = __fc_exn_kind___fc_i;
    __fc_exn.exn_obj.__fc_i = exn;
    __retres = 0;
    goto return_label;
  }
  else {
    __retres = c + 1;
    goto return_label;
  }
  return_label: return __retres;
}

int f3(int c)
{
  int __retres;
  if (c > 150) {
    int *exn;
    exn = & x;
    __fc_exn.exn_uncaught = 1;
    __fc_exn.exn_kind = __fc_exn_kind___fc_pi;
    __fc_exn.exn_obj.__fc_pi = exn;
    __retres = 0;
    goto return_label;
  }
  else {
    __retres = c + 2;
    goto return_label;
  }
  return_label: return __retres;
}

int f4(int c)
{
  int __retres;
  if (c) {
    struct my_exn2 exn;
    exn.c = 0;
    __fc_exn.exn_uncaught = 1;
    __fc_exn.exn_kind = __fc_exn_kind___fc_Smy_exn2;
    __fc_exn.exn_obj.__fc_Smy_exn2 = exn;
    __retres = 0;
    goto return_label;
  }
  else {
    __retres = c + 3;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ ensures __fc_exn.exn_uncaught ≡ 0 ⇒ \result ≢ 42; */
int h(int c)
{
  int __retres;
  {
    struct my_exn2 exn2;
    struct my_exn exn_aux;
    int y;
    struct my_exn exn;
    if (c - 1 <= 0) {
      int tmp;
      tmp = f1(c);
      if (__fc_exn.exn_uncaught == 1) 
        switch (__fc_exn.exn_kind) case __fc_exn_kind___fc_Smy_exn:
                                     goto __fc_Smy_exn_1;
      __retres = tmp;
      goto return_label;
    }
    else 
      if (c - 100 <= 0) {
        int tmp_0;
        /*@ returns __fc_exn.exn_uncaught ≡ 0 ⇒ \result ≡ c+1; */
        {
          tmp_0 = f2(c);
          if (__fc_exn.exn_uncaught == 1) 
            switch (__fc_exn.exn_kind) case __fc_exn_kind___fc_i:
                                         goto __fc_i;
          __retres = tmp_0;
          /*@ assert __retres ≡ c+1; */ ;
          goto return_label;
        }
      }
      else 
        if (c > 360) {
          int tmp_1;
          tmp_1 = f3(c);
          if (__fc_exn.exn_uncaught == 1) 
            switch (__fc_exn.exn_kind) {
              default: __retres = 0;
                       goto return_label;
            }
          __retres = tmp_1;
          goto return_label;
        }
        else {
          int tmp_2;
          tmp_2 = f4(c);
          if (__fc_exn.exn_uncaught == 1) 
            switch (__fc_exn.exn_kind) case __fc_exn_kind___fc_Smy_exn2:
                                         goto __fc_Smy_exn2_2;
          __retres = tmp_2;
          goto return_label;
        }
    if (0) {
      struct my_exn exn;
      if (0) {
        struct my_exn2 exn2;
        __fc_Smy_exn2_2: exn2 = __fc_exn.exn_obj.__fc_Smy_exn2;
        exn.e = exn2.c;
        goto __fc_Smy_exn;
      }
      if (0) {
        struct my_exn exn_aux;
        __fc_Smy_exn_1: exn_aux = __fc_exn.exn_obj.__fc_Smy_exn;
        exn = exn_aux;
        goto __fc_Smy_exn;
      }
      __fc_Smy_exn: __fc_exn.exn_uncaught = 0;
      __retres = exn.e;
      goto return_label;
    }
    if (0) {
      int y;
      __fc_i: __fc_exn.exn_uncaught = 0;
      y = __fc_exn.exn_obj.__fc_i;
      __retres = y;
      goto return_label;
    }
  }
  return_label: return __retres;
}


