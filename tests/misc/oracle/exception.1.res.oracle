[kernel] Parsing share/libc/__fc_builtin_for_normalization.i (no preprocessing)
[kernel] Parsing tests/misc/exception.i (no preprocessing)
/* Generated by Frama-C */
struct my_exn {
   int e ;
};
struct my_exn2 {
   char c ;
};
enum __fc_exn_enum {
    __fc_exn_kind___fc_Smy_exn2 = 3,
    __fc_exn_kind___fc_Smy_exn = 2,
    __fc_exn_kind___fc_pi = 1,
    __fc_exn_kind___fc_i = 0
};
union __fc_exn_union {
   struct my_exn2 __fc_Smy_exn2 ;
   struct my_exn __fc_Smy_exn ;
   int *__fc_pi ;
   int __fc_i ;
};
struct __fc_exn_struct {
   int exn_uncaught ;
   enum __fc_exn_enum exn_kind ;
   union __fc_exn_union exn_obj ;
};
struct __fc_exn_struct __fc_exn =
  {.exn_uncaught = 0,
   .exn_kind = 0,
   .exn_obj = {.__fc_Smy_exn2 = {.c = (char)0}}};
struct my_exn foo;
struct my_exn2 bar;
int x = 42;
int f(int c)
{
  int __retres;
  if (c) {
    __fc_exn.exn_uncaught = 1;
    __fc_exn.exn_kind = __fc_exn_kind___fc_i;
    __fc_exn.exn_obj.__fc_i = x;
    __retres = 0;
    goto return_label;
  }
  else {
    __retres = c;
    goto return_label;
  }
  return_label: return __retres;
}

int g(int c)
{
  int __retres;
  {
    int tmp;
    tmp = f(c);
    if (__fc_exn.exn_uncaught == 1) 
      switch (__fc_exn.exn_kind) case __fc_exn_kind___fc_i: goto __fc_i;
    __retres = tmp;
    goto return_label;
    if (0) {
      int x_0;
      __fc_i: __fc_exn.exn_uncaught = 0;
      x_0 = __fc_exn.exn_obj.__fc_i;
      __retres = 3;
      goto return_label;
    }
    if (0) {
      catch_all: __fc_exn.exn_uncaught = 0;
      __retres = 4;
      goto return_label;
    }
  }
  return_label: return __retres;
}

int f1(int c)
{
  int __retres;
  if (c) {
    struct my_exn exn;
    exn.e = 0;
    __fc_exn.exn_uncaught = 1;
    __fc_exn.exn_kind = __fc_exn_kind___fc_Smy_exn;
    __fc_exn.exn_obj.__fc_Smy_exn = exn;
    __retres = 0;
    goto return_label;
  }
  else {
    __retres = c;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ ensures __fc_exn.exn_uncaught ≡ 0 ⇒ \result ≡ \old(c) + 1; */
int f2(int c)
{
  int __retres;
  if (c < 50) {
    int exn;
    exn = 0;
    __fc_exn.exn_uncaught = 1;
    __fc_exn.exn_kind = __fc_exn_kind___fc_i;
    __fc_exn.exn_obj.__fc_i = exn;
    __retres = 0;
    goto return_label;
  }
  else {
    __retres = c + 1;
    goto return_label;
  }
  return_label: return __retres;
}

int f3(int c)
{
  int __retres;
  if (c > 150) {
    int *exn;
    exn = & x;
    __fc_exn.exn_uncaught = 1;
    __fc_exn.exn_kind = __fc_exn_kind___fc_pi;
    __fc_exn.exn_obj.__fc_pi = exn;
    __retres = 0;
    goto return_label;
  }
  else {
    __retres = c + 2;
    goto return_label;
  }
  return_label: return __retres;
}

int f4(int c)
{
  int __retres;
  if (c) {
    struct my_exn2 exn;
    exn.c = 0;
    __fc_exn.exn_uncaught = 1;
    __fc_exn.exn_kind = __fc_exn_kind___fc_Smy_exn2;
    __fc_exn.exn_obj.__fc_Smy_exn2 = exn;
    __retres = 0;
    goto return_label;
  }
  else {
    __retres = c + 3;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ ensures __fc_exn.exn_uncaught ≡ 0 ⇒ \result ≢ 42; */
int h(int c)
{
  int __retres;
  if (c - 1 <= 0) {
    int tmp;
    tmp = f1(c);
    if (__fc_exn.exn_uncaught == 1) 
      switch (__fc_exn.exn_kind) case __fc_exn_kind___fc_Smy_exn:
                                   goto __fc_Smy_exn_1;
    __retres = tmp;
    goto return_label;
  }
  else 
    if (c - 100 <= 0) {
      int tmp_0;
      /*@ returns __fc_exn.exn_uncaught ≡ 0 ⇒ \result ≡ c + 1; */
      {
        tmp_0 = f2(c);
        if (__fc_exn.exn_uncaught == 1) 
          switch (__fc_exn.exn_kind) case __fc_exn_kind___fc_i: goto __fc_i;
        __retres = tmp_0;
        /*@ assert __retres ≡ c + 1; */ ;
        goto return_label;
      }
    }
    else 
      if (c > 360) {
        int tmp_1;
        tmp_1 = f3(c);
        if (__fc_exn.exn_uncaught == 1) 
          switch (__fc_exn.exn_kind) default: goto catch_all;
        __retres = tmp_1;
        goto return_label;
      }
      else {
        int tmp_2;
        tmp_2 = f4(c);
        if (__fc_exn.exn_uncaught == 1) 
          switch (__fc_exn.exn_kind) case __fc_exn_kind___fc_Smy_exn2:
                                       goto __fc_Smy_exn2_2;
        __retres = tmp_2;
        goto return_label;
      }
  if (0) {
    struct my_exn exn;
    if (0) {
      struct my_exn2 exn2;
      __fc_Smy_exn2_2: exn2 = __fc_exn.exn_obj.__fc_Smy_exn2;
      exn.e = exn2.c;
      goto __fc_Smy_exn;
    }
    if (0) {
      struct my_exn exn_aux;
      __fc_Smy_exn_1: exn_aux = __fc_exn.exn_obj.__fc_Smy_exn;
      exn = exn_aux;
      goto __fc_Smy_exn;
    }
    __fc_Smy_exn: __fc_exn.exn_uncaught = 0;
    __retres = exn.e;
    goto return_label;
  }
  if (0) {
    int y;
    __fc_i: __fc_exn.exn_uncaught = 0;
    y = __fc_exn.exn_obj.__fc_i;
    __retres = y;
    goto return_label;
  }
  if (0) {
    catch_all: __fc_exn.exn_uncaught = 0;
    __fc_exn.exn_uncaught = 1;
    __retres = 0;
    goto return_label;
  }
  return_label: return __retres;
}


