[kernel] Parsing share/libc/__fc_builtin_for_normalization.i (no preprocessing)
[kernel] Parsing tests/spec/clash_double_file_bts1598.c (with preprocessing)
/* Generated by Frama-C */
typedef unsigned int size_t;
struct option {
   char const *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
typedef long long intmax_t;
struct __anonstruct_imaxdiv_t_1 {
   long long quot ;
   long long rem ;
};
typedef struct __anonstruct_imaxdiv_t_1 imaxdiv_t;
typedef int wchar_t;
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
typedef int jmp_buf[5];
typedef unsigned long sigset_t;
struct __anonstruct_sigjmp_buf_2 {
   jmp_buf buf ;
   sigset_t sigs ;
};
typedef struct __anonstruct_sigjmp_buf_2 sigjmp_buf;
typedef __builtin_va_list va_list;
typedef long time_t;
struct __fc_pos_t {
   unsigned long __fc_stdio_position ;
};
typedef struct __fc_pos_t fpos_t;
struct __fc_FILE {
   unsigned int __fc_FILE_id ;
   unsigned int __fc_FILE_data ;
};
typedef struct __fc_FILE FILE;
struct __fc_div_t {
   int quot ;
   int rem ;
};
typedef struct __fc_div_t div_t;
struct __fc_ldiv_t {
   long quot ;
   long rem ;
};
typedef struct __fc_ldiv_t ldiv_t;
struct __fc_lldiv_t {
   long long quot ;
   long long rem ;
};
typedef struct __fc_lldiv_t lldiv_t;
typedef unsigned int clock_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
};
extern int volatile Frama_C_entropy_source __attribute__((__unused__,
                                                          __FRAMA_C_MODEL__));

/*@ requires \valid(p + (0 .. l - 1));
    ensures \initialized(\old(p) + (0 .. \old(l) - 1));
    assigns *(p + (0 .. l - 1)), Frama_C_entropy_source;
    assigns *(p + (0 .. l - 1)) \from Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern void Frama_C_make_unknown(char *p, size_t l);

/*@ ensures \result ≡ \old(a) ∨ \result ≡ \old(b);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from a, b, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int Frama_C_nondet(int a, int b);

/*@ ensures \result ≡ \old(a) ∨ \result ≡ \old(b);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from a, b, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern void *Frama_C_nondet_ptr(void *a, void *b);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int Frama_C_interval(int min, int max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int Frama_C_interval_split(int min, int max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned char Frama_C_unsigned_char_interval(unsigned char min,
                                                    unsigned char max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern char Frama_C_char_interval(char min, char max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned short Frama_C_unsigned_short_interval(unsigned short min,
                                                      unsigned short max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern short Frama_C_short_interval(short min, short max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned int Frama_C_unsigned_int_interval(unsigned int min,
                                                  unsigned int max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int Frama_C_int_interval(int min, int max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned long Frama_C_unsigned_long_interval(unsigned long min,
                                                    unsigned long max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern long Frama_C_long_interval(long min, long max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned long long Frama_C_unsigned_long_long_interval(unsigned long long min,
                                                              unsigned long long max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern long long Frama_C_long_long_interval(long long min, long long max);

/*@ requires \is_finite(min) ∧ \is_finite(max);
    requires min ≤ max;
    ensures \is_finite(\result) ∧ \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern float Frama_C_float_interval(float min, float max);

/*@ requires \is_finite(min) ∧ \is_finite(max);
    requires min ≤ max;
    ensures \is_finite(\result) ∧ \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern double Frama_C_double_interval(double min, double max);

/*@ assigns *((char *)dest + (0 .. n - 1)), \result;
    assigns *((char *)dest + (0 .. n - 1))
      \from *((char *)src + (0 .. n - 1));
    assigns \result \from dest;
 */
extern void *Frama_C_memcpy(void *dest, void const *src, size_t n);

/*@ assigns *((char *)p + (0 .. s - 1)), \result;
    assigns *((char *)p + (0 .. s - 1)) \from c;
    assigns \result \from p;
 */
extern void *Frama_C_memset(void *p, int c, size_t s);

/*@ requires \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void Frama_C_abort(void);

/*@ assigns \result;
    assigns \result \from p; */
extern size_t Frama_C_offset(void const *p);

/*@ requires \false;
    terminates \false;
    assigns \nothing; */
extern void __FC_assert(char const *file, int line, char const *expr);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_not_match:
      assumes
        c ≡ -1 ∨ (0 ≤ c ≤ 47) ∨ (58 ≤ c ≤ 64) ∨
        (91 ≤ c ≤ 96) ∨ (123 ≤ c ≤ 127);
      ensures \result ≡ 0;
    
    behavior definitely_match:
      assumes
        ('A' ≤ c ≤ 'Z') ∨ ('a' ≤ c ≤ 'z') ∨ ('0' ≤ c ≤ '9');
      ensures \result < 0 ∨ \result > 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int isalnum(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_not_match:
      assumes
        c ≡ -1 ∨ (0 ≤ c ≤ 64) ∨ (91 ≤ c ≤ 96) ∨
        (123 ≤ c ≤ 127);
      ensures \result ≡ 0;
    
    behavior definitely_match:
      assumes ('A' ≤ c ≤ 'Z') ∨ ('a' ≤ c ≤ 'z');
      ensures \result < 0 ∨ \result > 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int isalpha(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior match:
      assumes c ≡ ' ' ∨ c ≡ '\t';
      ensures \result < 0 ∨ \result > 0;
    
    behavior no_match:
      assumes c ≢ ' ' ∧ c ≢ '\t';
      ensures \result ≡ 0;
    
    complete behaviors match, no_match;
    disjoint behaviors match, no_match;
 */
extern int isblank(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes (0 ≤ c ≤ 31) ∨ c ≡ 127;
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c ≡ -1 ∨ (32 ≤ c ≤ 126);
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int iscntrl(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior match:
      assumes '0' ≤ c ≤ '9';
      ensures \result < 0 ∨ \result > 0;
    
    behavior no_match:
      assumes c < '0' ∨ c > '9';
      ensures \result ≡ 0;
    
    complete behaviors match, no_match;
    disjoint behaviors match, no_match;
 */
extern int isdigit(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes 33 ≤ c ≤ 126;
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c ≡ -1 ∨ (0 ≤ c ≤ 32) ∨ c ≡ 127;
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int isgraph(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes 'a' ≤ c ≤ 'z';
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c ≡ -1 ∨ (0 ≤ c < 'a') ∨ ('z' < c < 127);
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int islower(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes 32 ≤ c ≤ 126;
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c ≡ -1 ∨ (0 ≤ c ≤ 31) ∨ c ≡ 127;
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int isprint(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes
        (33 ≤ c ≤ 47) ∨ (58 ≤ c ≤ 64) ∨ (91 ≤ c ≤ 96) ∨
        (123 ≤ c ≤ 126);
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes
        c ≡ -1 ∨ (0 ≤ c ≤ 32) ∨ (48 ≤ c ≤ 57) ∨
        (65 ≤ c ≤ 90) ∨ (97 ≤ c ≤ 122) ∨ c ≡ 127;
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int ispunct(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes (9 ≤ c ≤ 13) ∨ c ≡ ' ';
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes
        c ≡ -1 ∨ (0 ≤ c ≤ 8) ∨ (14 ≤ c < ' ') ∨
        (' ' < c ≤ 127);
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int isspace(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes 'A' ≤ c ≤ 'Z';
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c ≡ -1 ∨ (0 ≤ c < 'A') ∨ ('Z' < c ≤ 127);
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int isupper(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior match:
      assumes
        ('0' ≤ c ≤ '9') ∨ ('A' ≤ c ≤ 'F') ∨ ('a' ≤ c ≤ 'f');
      ensures \result < 0 ∨ \result > 0;
    
    behavior no_match:
      assumes
        ¬(('0' ≤ c ≤ '9') ∨ ('A' ≤ c ≤ 'F') ∨
           ('a' ≤ c ≤ 'f'));
      ensures \result ≡ 0;
    
    complete behaviors match, no_match;
    disjoint behaviors match, no_match;
 */
extern int isxdigit(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    ensures (0 ≤ \result ≤ 255) ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_changed:
      assumes 'A' ≤ c ≤ 'Z';
      ensures \result ≡ \old(c) + 32;
    
    behavior definitely_not_changed:
      assumes c ≡ -1 ∨ (0 ≤ c < 'A') ∨ ('Z' < c ≤ 127);
      ensures \result ≡ \old(c);
    
    disjoint behaviors definitely_changed, definitely_not_changed;
 */
extern int tolower(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    ensures (0 ≤ \result ≤ 255) ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_changed:
      assumes 'a' ≤ c ≤ 'z';
      ensures \result ≡ \old(c) - 32;
    
    behavior definitely_not_changed:
      assumes c ≡ -1 ∨ (0 ≤ c < 'a') ∨ ('z' < c ≤ 127);
      ensures \result ≡ \old(c);
    
    disjoint behaviors definitely_changed, definitely_not_changed;
 */
extern int toupper(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior match:
      assumes 0 ≤ c ≤ 127;
      ensures \result < 0 ∨ \result > 0;
    
    behavior no_match:
      assumes ¬(0 ≤ c ≤ 127);
      ensures \result ≡ 0;
    
    complete behaviors match, no_match;
    disjoint behaviors match, no_match;
 */
extern int isascii(int c);

extern int __FC_errno;

extern char *optarg;

extern int optind;

extern int opterr;

extern int optopt;

/*@ assigns \result, *optarg, optind, opterr, optopt;
    assigns \result
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
    assigns *optarg
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
    assigns optind
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
    assigns opterr
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
    assigns optopt
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
 */
extern int getopt(int argc, char * const *argv, char const *optstring);

/*@ assigns \result, *optarg, optind, opterr, optopt,
            *((longopts + (0 ..))->flag);
    assigns \result
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns *optarg
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns optind
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns opterr
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns optopt
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns *((longopts + (0 ..))->flag)
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
 */
extern int getopt_long(int argc, char * const *argv, char const *shortopts,
                       struct option const *longopts, int *longind);

/*@ assigns \result, *optarg, optind, opterr, optopt,
            *((longopts + (0 ..))->flag);
    assigns \result
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns *optarg
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns optind
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns opterr
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns optopt
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns *((longopts + (0 ..))->flag)
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
 */
extern int getopt_long_only(int argc, char * const *argv,
                            char const *shortopts,
                            struct option const *longopts, int *longind);

/*@ requires (intmax_t)(-c) ≢ c;
    assigns \result;
    assigns \result \from c;
 */
extern intmax_t imaxabs(intmax_t c);

/*@ requires denom ≢ 0;
    ensures \result.quot ≡ \old(numer) / \old(denom);
    ensures \result.rem ≡ \old(numer) % \old(denom);
    assigns \result;
    assigns \result \from numer, denom;
 */
extern imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);

/*@ assigns \result, *(endptr + (..)), __FC_errno;
    assigns \result \from *(nptr + (..)), base;
    assigns *(endptr + (..)) \from *(nptr + (..)), base;
    assigns __FC_errno \from *(nptr + (..)), base;
 */
extern intmax_t strtoimax(char const *nptr, char **endptr, int base);

/*@
axiomatic MemCmp {
  logic ℤ memcmp{L1, L2}(char *s1, char *s2, ℤ n) 
    reads \at(*(s1 + (0 .. n - 1)),L1), \at(*(s2 + (0 .. n - 1)),L2);
  
  axiom memcmp_zero{L1, L2}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L1, L2}(s1, s2, n) ≡ 0 ⇔
      (∀ ℤ i; 0 ≤ i < n ⇒ \at(*(s1 + i),L1) ≡ \at(*(s2 + i),L2));
  
  }
 */
/*@
axiomatic MemChr {
  logic 𝔹 memchr{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom memchr_def{L}:
    ∀ char *s;
    ∀ ℤ c;
    ∀ ℤ n;
      memchr(s, c, n) ≡ \true ⇔
      (∃ int i; 0 ≤ i < n ∧ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic MemSet {
  logic 𝔹 memset{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom memset_def{L}:
    ∀ char *s;
    ∀ ℤ c;
    ∀ ℤ n;
      memset(s, c, n) ≡ \true ⇔
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic StrLen {
  logic ℤ strlen{L}(char *s) 
    reads *(s + (0 ..));
  
  axiom strlen_pos_or_null{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ∧ (∀ ℤ j; 0 ≤ j < i ⇒ *(s + j) ≢ '\000') ∧
      *(s + i) ≡ '\000' ⇒ strlen(s) ≡ i;
  
  axiom strlen_neg{L}:
    ∀ char *s;
      (∀ ℤ i; 0 ≤ i ⇒ *(s + i) ≢ '\000') ⇒ strlen(s) < 0;
  
  axiom strlen_before_null{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i < strlen(s) ⇒ *(s + i) ≢ '\000';
  
  axiom strlen_at_null{L}:
    ∀ char *s; 0 ≤ strlen(s) ⇒ *(s + strlen(s)) ≡ '\000';
  
  axiom strlen_not_zero{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ≤ strlen(s) ∧ *(s + i) ≢ '\000' ⇒ i < strlen(s);
  
  axiom strlen_zero{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ≤ strlen(s) ∧ *(s + i) ≡ '\000' ⇒ i ≡ strlen(s);
  
  axiom strlen_sup{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ∧ *(s + i) ≡ '\000' ⇒ 0 ≤ strlen(s) ≤ i;
  
  axiom strlen_shift{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ≤ strlen(s) ⇒ strlen(s + i) ≡ strlen(s) - i;
  
  axiom strlen_create{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ∧ *(s + i) ≡ '\000' ⇒ 0 ≤ strlen(s) ≤ i;
  
  axiom strlen_create_shift{L}:
    ∀ char *s;
    ∀ ℤ i;
    ∀ ℤ k;
      0 ≤ k ≤ i ∧ *(s + i) ≡ '\000' ⇒ 0 ≤ strlen(s + k) ≤ i - k;
  
  axiom memcmp_strlen_left{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L, L}(s1, s2, n) ≡ 0 ∧ strlen(s1) < n ⇒
      strlen(s1) ≡ strlen(s2);
  
  axiom memcmp_strlen_right{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L, L}(s1, s2, n) ≡ 0 ∧ strlen(s2) < n ⇒
      strlen(s1) ≡ strlen(s2);
  
  axiom memcmp_strlen_shift_left{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ k, ℤ n;
      memcmp{L, L}(s1, s2 + k, n) ≡ 0 ≤ k ∧ strlen(s1) < n ⇒
      0 ≤ strlen(s2) ≤ k + strlen(s1);
  
  axiom memcmp_strlen_shift_right{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ k, ℤ n;
      memcmp{L, L}(s1 + k, s2, n) ≡ 0 ≤ k ∧ strlen(s2) < n ⇒
      0 ≤ strlen(s1) ≤ k + strlen(s2);
  
  }
 */
/*@
axiomatic StrCmp {
  logic ℤ strcmp{L}(char *s1, char *s2) 
    reads *(s1 + (0 .. strlen(s1))), *(s2 + (0 .. strlen(s2)));
  
  axiom strcmp_zero{L}:
    ∀ char *s1, char *s2;
      strcmp(s1, s2) ≡ 0 ⇔
      strlen(s1) ≡ strlen(s2) ∧
      (∀ ℤ i; 0 ≤ i ≤ strlen(s1) ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic StrNCmp {
  logic ℤ strncmp{L}(char *s1, char *s2, ℤ n) 
    reads *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
  
  axiom strncmp_zero{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      strncmp(s1, s2, n) ≡ 0 ⇔
      (strlen(s1) < n ∧ strcmp(s1, s2) ≡ 0) ∨
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic StrChr {
  logic 𝔹 strchr{L}(char *s, ℤ c) 
    reads *(s + (0 .. strlen(s)));
  
  axiom strchr_def{L}:
    ∀ char *s;
    ∀ ℤ c;
      strchr(s, c) ≡ \true ⇔
      (∃ ℤ i; 0 ≤ i ≤ strlen(s) ∧ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic WcsLen {
  logic ℤ wcslen{L}(wchar_t *s) 
    reads *(s + (0 ..));
  
  axiom wcslen_pos_or_null{L}:
    ∀ wchar_t *s;
    ∀ ℤ i;
      0 ≤ i ∧ (∀ ℤ j; 0 ≤ j < i ⇒ *(s + j) ≢ 0) ∧
      *(s + i) ≡ 0 ⇒ wcslen(s) ≡ i;
  
  axiom wcslen_neg{L}:
    ∀ wchar_t *s; (∀ ℤ i; 0 ≤ i ⇒ *(s + i) ≢ 0) ⇒ wcslen(s) < 0;
  
  axiom wcslen_before_null{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i < wcslen(s) ⇒ *(s + i) ≢ 0;
  
  axiom wcslen_at_null{L}:
    ∀ wchar_t *s; 0 ≤ wcslen(s) ⇒ *(s + wcslen(s)) ≡ 0;
  
  axiom wcslen_not_zero{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ≤ wcslen(s) ∧ *(s + i) ≢ 0 ⇒ i < wcslen(s);
  
  axiom wcslen_zero{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ≤ wcslen(s) ∧ *(s + i) ≡ 0 ⇒ i ≡ wcslen(s);
  
  axiom wcslen_sup{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ∧ *(s + i) ≡ 0 ⇒ 0 ≤ wcslen(s) ≤ i;
  
  axiom wcslen_shift{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ≤ wcslen(s) ⇒ wcslen(s + i) ≡ wcslen(s) - i;
  
  axiom wcslen_create{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ∧ *(s + i) ≡ 0 ⇒ 0 ≤ wcslen(s) ≤ i;
  
  axiom wcslen_create_shift{L}:
    ∀ wchar_t *s;
    ∀ int i;
    ∀ int k;
      0 ≤ k ≤ i ∧ *(s + i) ≡ 0 ⇒ 0 ≤ wcslen(s + k) ≤ i - k;
  
  }
 */
/*@
axiomatic WcsCmp {
  logic ℤ wcscmp{L}(wchar_t *s1, wchar_t *s2) 
    reads *(s1 + (0 .. wcslen(s1))), *(s2 + (0 .. wcslen(s2)));
  
  axiom wcscmp_zero{L}:
    ∀ wchar_t *s1, wchar_t *s2;
      wcscmp(s1, s2) ≡ 0 ⇔
      wcslen(s1) ≡ wcslen(s2) ∧
      (∀ ℤ i; 0 ≤ i ≤ wcslen(s1) ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic WcsNCmp {
  logic ℤ wcsncmp{L}(wchar_t *s1, wchar_t *s2, ℤ n) 
    reads *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
  
  axiom wcsncmp_zero{L}:
    ∀ wchar_t *s1, wchar_t *s2;
    ∀ ℤ n;
      wcsncmp(s1, s2, n) ≡ 0 ⇔
      (wcslen(s1) < n ∧ wcscmp(s1, s2) ≡ 0) ∨
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@ logic ℤ minimum(ℤ i, ℤ j) = i < j? i: j;
 */
/*@ logic ℤ maximum(ℤ i, ℤ j) = i < j? j: i;
 */
/*@
predicate valid_string{L}(char *s) =
  0 ≤ strlen(s) ∧ \valid(s + (0 .. strlen(s)));
 */
/*@
predicate valid_read_string{L}(char *s) =
  0 ≤ strlen(s) ∧ \valid_read(s + (0 .. strlen(s)));
 */
/*@
predicate valid_string_or_null{L}(char *s) = s ≡ \null ∨ valid_string(s);
 */
/*@
predicate valid_wstring{L}(wchar_t *s) =
  0 ≤ wcslen(s) ∧ \valid(s + (0 .. wcslen(s)));
 */
/*@
predicate valid_wstring_or_null{L}(wchar_t *s) =
  s ≡ \null ∨ valid_wstring(s);
 */
extern struct lconv *__frama_c_locale;

extern char *__frama_c_locale_names[];

/*@ requires locale ≡ \null ∨ valid_read_string(locale);
    ensures
      \result ≡ \null ∨
      (\valid(\result) ∧ (∃ ℤ i; \result ≡ __frama_c_locale_names[i]));
    assigns __frama_c_locale, \result;
    assigns __frama_c_locale \from category, *(locale + (..));
    assigns \result \from __frama_c_locale, category, *(locale + (..));
 */
extern char *setlocale(int category, char const *locale);

/*@ ensures \result ≡ __frama_c_locale;
    assigns \nothing; */
extern struct lconv *localeconv(void);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, edom;
 */
extern double acos(double x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, edom;
 */
extern float acosf(float x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, edom;
 */
extern long double acosl(long double x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, edom;
 */
extern double asin(double x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, edom;
 */
extern float asinf(float x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, edom;
 */
extern long double asinl(long double x);

/*@ assigns \result;
    assigns \result \from y, x; */
extern double atan2(double y, double x);

/*@ assigns \result;
    assigns \result \from x; */
extern double cos(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern double sin(double x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ x ≥ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior infinite:
      assumes \is_plus_infinity(x);
      ensures \is_plus_infinity(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_minus_infinity(x) ∨ (\is_finite(x) ∧ x < 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, infinite, edom;
 */
extern double acosh(double x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ x ≥ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior infinite:
      assumes \is_plus_infinity(x);
      ensures \is_plus_infinity(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_minus_infinity(x) ∨ (\is_finite(x) ∧ x < 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, infinite, edom;
 */
extern float acoshf(float x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ x ≥ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior infinite:
      assumes \is_plus_infinity(x);
      ensures \is_plus_infinity(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_minus_infinity(x) ∨ (\is_finite(x) ∧ x < 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, infinite, edom;
 */
extern long double acoshl(long double x);

/*@ assigns \result;
    assigns \result \from x; */
extern double exp(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float expf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double log(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float logf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double log10(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float log10f(float x);

/*@ assigns \result;
    assigns \result \from x, y; */
extern double pow(double x, double y);

/*@ assigns \result;
    assigns \result \from x, y; */
extern float powf(float x, float y);

/*@ assigns \result;
    assigns \result \from x; */
extern double sqrt(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float sqrtf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double ceil(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float ceilf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double floor(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float floorf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double round(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float roundf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double trunc(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float truncf(float x);

/*@ assigns \result;
    assigns \result \from x, y; */
extern double fmod(double x, double y);

/*@ requires valid_read_string(tagp);
    ensures \is_NaN(\result);
    assigns \nothing;
 */
extern double nan(char const *tagp);

/*@ requires valid_read_string(tagp);
    ensures \is_NaN(\result);
    assigns \nothing;
 */
extern float nanf(char const *tagp);

/*@ requires valid_read_string(tagp);
    ensures \is_NaN(\result);
    assigns \nothing;
 */
extern long double nanl(char const *tagp);

/*@ assigns *(env + (0 .. 4)); */
extern int setjmp(int * /*[5]*/ env);

/*@ ensures \false;
    assigns \nothing; */
extern void longjmp(int * /*[5]*/ env, int val);

/*@ ensures \false;
    assigns \nothing; */
extern void siglongjmp(sigjmp_buf env, int val);

/*@ assigns \nothing; */
extern void (*signal(int sig, void (*func)(int )))(int );

/*@ ensures \false;
    assigns \nothing; */
extern int raise(int sig);

extern FILE *__fc_stdin;

extern FILE *__fc_stdout;

/*@ assigns \nothing; */
extern int remove(char const *filename);

/*@ assigns \nothing; */
extern int rename(char const *old_name, char const *new_name);

/*@ ensures
      \result ≡ \null ∨
      (\valid(\result) ∧ \fresh{Old, Here}(\result,sizeof(FILE)));
    assigns \nothing;
 */
extern FILE *tmpfile(void);

/*@ assigns \result, *(s + (..));
    assigns \result \from *(s + (..));
    assigns *(s + (..)) \from \nothing;
 */
extern char *tmpnam(char *s);

/*@ requires \valid(stream);
    ensures \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from stream, stream->__fc_FILE_id;
 */
extern int fclose(FILE *stream);

/*@ requires stream ≡ \null ∨ \valid_read(stream);
    ensures \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from stream, stream->__fc_FILE_id;
 */
extern int fflush(FILE *stream);

FILE __fc_fopen[512];
FILE * const __p_fc_fopen = __fc_fopen;
/*@ ensures
      \result ≡ \null ∨ \subset(\result, &__fc_fopen[0 .. 512 - 1]);
    assigns \result;
    assigns \result \from *(filename + (..)), *(mode + (..)), __p_fc_fopen;
 */
extern FILE *fopen(char const *filename, char const *mode);

/*@ ensures
      \result ≡ \null ∨
      (\valid(\result) ∧ \fresh{Old, Here}(\result,sizeof(FILE)));
    assigns \result;
    assigns \result \from fildes, *(mode + (..));
 */
extern FILE *fdopen(int fildes, char const *mode);

/*@ ensures \result ≡ \null ∨ \result ≡ \old(stream);
    assigns *stream;
 */
extern FILE *freopen(char const *filename, char const *mode, FILE *stream);

/*@ assigns *stream;
    assigns *stream \from buf; */
extern void setbuf(FILE *stream, char *buf);

/*@ assigns *stream;
    assigns *stream \from buf, mode, size; */
extern int setvbuf(FILE *stream, char *buf, int mode, size_t size);

/*@ assigns *stream;
    assigns *stream \from stream->__fc_FILE_id; */
extern int fprintf(FILE *stream, char const *format , ...);

/*@ assigns *stream;
    assigns *stream \from stream->__fc_FILE_id; */
extern int fscanf(FILE *stream, char const *format , ...);

/*@ assigns *__fc_stdout;
    assigns *__fc_stdout \from *(format + (..)); */
extern int printf(char const *format , ...);

/*@ assigns *__fc_stdin; */
extern int scanf(char const *format , ...);

/*@ assigns *(s + (0 .. n - 1)); */
extern int snprintf(char *s, size_t n, char const *format , ...);

/*@ assigns *(s + (0 ..)); */
extern int sprintf(char *s, char const *format , ...);

/*@ assigns *stream;
    assigns *stream \from *(format + (..)), arg; */
extern int vfprintf(FILE *stream, char const *format, va_list arg);

/*@ assigns *stream;
    assigns *stream \from *(format + (..)), *stream; */
extern int vfscanf(FILE *stream, char const *format, va_list arg);

/*@ assigns *__fc_stdout;
    assigns *__fc_stdout \from arg; */
extern int vprintf(char const *format, va_list arg);

/*@ assigns *__fc_stdin;
    assigns *__fc_stdin \from *(format + (..)); */
extern int vscanf(char const *format, va_list arg);

/*@ assigns *(s + (0 .. n - 1));
    assigns *(s + (0 .. n - 1)) \from *(format + (..)), arg;
 */
extern int vsnprintf(char *s, size_t n, char const *format, va_list arg);

/*@ assigns *(s + (0 ..));
    assigns *(s + (0 ..)) \from *(format + (..)), arg;
 */
extern int vsprintf(char *s, char const *format, va_list arg);

/*@ assigns *stream; */
extern int fgetc(FILE *stream);

/*@ ensures \result ≡ \null ∨ \result ≡ \old(s);
    assigns *(s + (0 .. n - 1)), *stream, \result;
    assigns *(s + (0 .. n - 1)) \from *stream;
    assigns *stream \from *stream;
    assigns \result \from s, n, *stream;
 */
extern char *fgets(char *s, int n, FILE *stream);

/*@ assigns *stream; */
extern int fputc(int c, FILE *stream);

/*@ assigns *stream;
    assigns *stream \from *(s + (..)); */
extern int fputs(char const *s, FILE *stream);

/*@ assigns \result, *stream;
    assigns \result \from *stream;
    assigns *stream \from *stream;
 */
extern int getc(FILE *stream);

/*@ assigns \result;
    assigns \result \from *__fc_stdin; */
extern int getchar(void);

/*@ ensures \result ≡ \old(s) ∨ \result ≡ \null;
    assigns *(s + (..)), \result;
    assigns *(s + (..)) \from *__fc_stdin;
    assigns \result \from s, __fc_stdin;
 */
extern char *gets(char *s);

/*@ assigns *stream;
    assigns *stream \from c; */
extern int putc(int c, FILE *stream);

/*@ assigns *__fc_stdout;
    assigns *__fc_stdout \from c; */
extern int putchar(int c);

/*@ assigns *__fc_stdout;
    assigns *__fc_stdout \from *(s + (..)); */
extern int puts(char const *s);

/*@ assigns *stream;
    assigns *stream \from c; */
extern int ungetc(int c, FILE *stream);

/*@ requires \valid((char *)ptr + (0 .. nmemb * size - 1));
    requires \valid(stream);
    ensures \result ≤ \old(nmemb);
    ensures
      \initialized((char *)\old(ptr) + (0 .. \result * \old(size) - 1));
    assigns *((char *)ptr + (0 .. nmemb * size - 1)), \result;
    assigns *((char *)ptr + (0 .. nmemb * size - 1))
      \from size, nmemb, *stream;
    assigns \result \from size, *stream;
 */
extern size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);

/*@ requires \valid_read((char *)ptr + (0 .. nmemb * size - 1));
    requires \valid(stream);
    ensures \result ≤ \old(nmemb);
    assigns *stream, \result;
    assigns *stream \from *((char *)ptr + (0 .. nmemb * size - 1));
    assigns \result \from *((char *)ptr + (0 .. nmemb * size - 1));
 */
extern size_t fwrite(void const *ptr, size_t size, size_t nmemb, FILE *stream);

/*@ assigns *pos;
    assigns *pos \from *stream; */
extern int fgetpos(FILE *stream, fpos_t *pos);

/*@ assigns *stream, __FC_errno;
    assigns *stream \from offset, whence; */
extern int fseek(FILE *stream, long offset, int whence);

/*@ assigns *stream;
    assigns *stream \from *pos; */
extern int fsetpos(FILE *stream, fpos_t const *pos);

/*@ assigns \result, __FC_errno;
    assigns \result \from *stream;
    assigns __FC_errno \from *stream;
 */
extern long ftell(FILE *stream);

/*@ assigns *stream;
    assigns *stream \from \nothing; */
extern void rewind(FILE *stream);

/*@ assigns *stream;
    assigns *stream \from \nothing; */
extern void clearerr(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int feof(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int fileno(FILE *stream);

/*@ assigns *stream;
    assigns *stream \from \nothing; */
extern void flockfile(FILE *stream);

/*@ assigns *stream;
    assigns *stream \from \nothing; */
extern void funlockfile(FILE *stream);

/*@ assigns \result, *stream;
    assigns \result \from \nothing;
    assigns *stream \from \nothing;
 */
extern int ftrylockfile(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int ferror(FILE *stream);

/*@ assigns __fc_stdout;
    assigns __fc_stdout \from __FC_errno, *(s + (..));
 */
extern void perror(char const *s);

/*@ assigns \result, *stream;
    assigns \result \from *stream;
    assigns *stream \from *stream;
 */
extern int getc_unlocked(FILE *stream);

/*@ assigns \result;
    assigns \result \from *__fc_stdin; */
extern int getchar_unlocked(void);

/*@ assigns *stream;
    assigns *stream \from c; */
extern int putc_unlocked(int c, FILE *stream);

/*@ assigns *__fc_stdout;
    assigns *__fc_stdout \from c; */
extern int putchar_unlocked(int c);

/*@ assigns *stream;
    assigns *stream \from \nothing; */
extern void clearerr_unlocked(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int feof_unlocked(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int ferror_unlocked(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int fileno_unlocked(FILE *stream);

/*@ assigns \result;
    assigns \result \from *(nptr + (..)); */
extern double atof(char const *nptr);

/*@ assigns \result;
    assigns \result \from *(nptr + (..)); */
extern int atoi(char const *nptr);

/*@ assigns \result;
    assigns \result \from *(nptr + (..)); */
extern long atol(char const *nptr);

/*@ assigns \result;
    assigns \result \from *(nptr + (..)); */
extern long long atoll(char const *nptr);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr + (0 ..));
    assigns *endptr \from nptr, *(nptr + (0 ..));
 */
extern double strtod(char const *nptr, char **endptr);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr + (0 ..));
    assigns *endptr \from nptr, *(nptr + (0 ..));
 */
extern float strtof(char const *nptr, char **endptr);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr + (0 ..));
    assigns *endptr \from nptr, *(nptr + (0 ..));
 */
extern long double strtold(char const *nptr, char **endptr);

/*@ assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior null_endptr:
      assumes endptr ≡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior nonnull_endptr:
      assumes endptr ≢ \null;
      requires \valid(endptr);
      ensures \initialized(\old(endptr));
      ensures \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors nonnull_endptr, null_endptr;
    disjoint behaviors nonnull_endptr, null_endptr;
 */
extern long strtol(char const *nptr, char **endptr, int base);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr + (0 ..)), base;
    assigns *endptr \from nptr, *(nptr + (0 ..)), base;
 */
extern long long strtoll(char const *nptr, char **endptr, int base);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr + (0 ..)), base;
    assigns *endptr \from nptr, *(nptr + (0 ..)), base;
 */
extern unsigned long strtoul(char const *nptr, char **endptr, int base);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr + (0 ..)), base;
    assigns *endptr \from nptr, *(nptr + (0 ..)), base;
 */
extern unsigned long long strtoull(char const *nptr, char **endptr, int base);

/*@ ghost
  int __fc_random_counter __attribute__((__unused__, __FRAMA_C_MODEL__)); */
unsigned long const __fc_rand_max = (unsigned long)32767;
/*@ ensures 0 ≤ \result ≤ __fc_rand_max;
    assigns \result, __fc_random_counter;
    assigns \result \from __fc_random_counter;
    assigns __fc_random_counter \from __fc_random_counter;
 */
extern int rand(void);

/*@ assigns __fc_random_counter;
    assigns __fc_random_counter \from seed; */
extern void srand(unsigned int seed);

/*@ requires nmemb * size ≤ 4294967295U; */
extern void *calloc(size_t nmemb, size_t size);

/*@ ghost extern int __fc_heap_status __attribute__((__FRAMA_C_MODEL__)); */

/*@
axiomatic dynamic_allocation {
  predicate is_allocable{L}(size_t n) 
    reads __fc_heap_status;
  
  }
 */
/*@ assigns __fc_heap_status, \result;
    assigns __fc_heap_status \from size, __fc_heap_status;
    assigns \result \from (indirect: size), (indirect: __fc_heap_status);
    allocates \result;
    
    behavior allocation:
      assumes is_allocable(size);
      ensures \fresh{Old, Here}(\result,\old(size));
      assigns __fc_heap_status, \result;
      assigns __fc_heap_status \from size, __fc_heap_status;
      assigns \result \from (indirect: size), (indirect: __fc_heap_status);
    
    behavior no_allocation:
      assumes ¬is_allocable(size);
      ensures \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
extern void *malloc(size_t size);

/*@ assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status;
    frees p;
    
    behavior deallocation:
      assumes p ≢ \null;
      requires freeable: \freeable(p);
      ensures \allocable(\old(p));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status;
    
    behavior no_deallocation:
      assumes p ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_deallocation, deallocation;
    disjoint behaviors no_deallocation, deallocation;
 */
extern void free(void *p);

/*@ requires ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status, \result;
    assigns __fc_heap_status \from __fc_heap_status;
    assigns \result \from size, ptr, __fc_heap_status;
    frees ptr;
    allocates \result;
    
    behavior alloc:
      assumes is_allocable(size);
      ensures \fresh{Old, Here}(\result,\old(size));
      assigns \result;
      assigns \result \from size, __fc_heap_status;
      allocates \result;
    
    behavior dealloc:
      assumes ptr ≢ \null;
      assumes is_allocable(size);
      requires \freeable(ptr);
      ensures \allocable(\old(ptr));
      ensures \result ≡ \null ∨ \freeable(\result);
      frees ptr;
    
    behavior fail:
      assumes ¬is_allocable(size);
      ensures \result ≡ \null;
      assigns \result;
      assigns \result \from size, __fc_heap_status;
      allocates \nothing;
    
    complete behaviors fail, dealloc, alloc;
    disjoint behaviors alloc, fail;
    disjoint behaviors dealloc, fail;
 */
extern void *realloc(void *ptr, size_t size);

/*@ ensures \false;
    assigns \nothing; */
extern void abort(void);

/*@ assigns \result;
    assigns \result \from \nothing; */
extern int atexit(void (*func)(void));

/*@ assigns \result;
    assigns \result \from \nothing; */
extern int at_quick_exit(void (*func)(void));

/*@ ensures \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void exit(int status);

/*@ ensures \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void _Exit(int status);

/*@ ensures \result ≡ \null ∨ \valid(\result);
    assigns \result;
    assigns \result \from name;
 */
extern char *getenv(char const *name);

/*@ ensures \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void quick_exit(int status);

/*@ assigns \result;
    assigns \result \from *(string + (..)); */
extern int system(char const *string);

/*@ assigns *((char *)\result + (..));
    assigns *((char *)\result + (..))
      \from *((char *)key + (..)), *((char *)base + (..)), nmemb, size,
            *compar;
 */
extern void *bsearch(void const *key, void const *base, size_t nmemb,
                     size_t size, int (*compar)(void const *, void const *));

/*@ assigns *((char *)base + (..));
    assigns *((char *)base + (..))
      \from *((char *)base + (..)), nmemb, size, *compar;
 */
extern void qsort(void *base, size_t nmemb, size_t size,
                  int (*compar)(void const *, void const *));

/*@ requires abs_representable: (int)(-j) ≡ -j;
    assigns \result;
    assigns \result \from j;
 */
extern int abs(int j);

/*@ requires abs_representable: (long)(-j) ≡ -j;
    assigns \result;
    assigns \result \from j;
 */
extern long labs(long j);

/*@ requires abs_representable: (long long)(-j) ≡ -j;
    assigns \result;
    assigns \result \from j;
 */
extern long long llabs(long long j);

/*@ assigns \result;
    assigns \result \from numer, denom; */
extern div_t div(int numer, int denom);

/*@ assigns \result;
    assigns \result \from numer, denom; */
extern ldiv_t ldiv(long numer, long denom);

/*@ assigns \result;
    assigns \result \from numer, denom; */
extern lldiv_t lldiv(long long numer, long long denom);

/*@ assigns \result;
    assigns \result \from *(s + (0 ..)), n; */
extern int mblen(char const *s, size_t n);

/*@ assigns \result, *(pwc + (0 .. n - 1));
    assigns \result \from *(s + (0 .. n - 1)), n;
    assigns *(pwc + (0 .. n - 1)) \from *(s + (0 .. n - 1)), n;
 */
extern int mbtowc(wchar_t *pwc, char const *s, size_t n);

/*@ assigns \result, *(s + (0 ..));
    assigns \result \from wc;
    assigns *(s + (0 ..)) \from wc;
 */
extern int wctomb(char *s, wchar_t wc);

/*@ assigns \result, *(pwcs + (0 .. n - 1));
    assigns \result \from *(s + (0 .. n - 1)), n;
    assigns *(pwcs + (0 .. n - 1)) \from *(s + (0 .. n - 1)), n;
 */
extern size_t mbstowcs(wchar_t *pwcs, char const *s, size_t n);

/*@ assigns \result, *(s + (0 .. n - 1));
    assigns \result \from *(pwcs + (0 .. n - 1)), n;
    assigns *(s + (0 .. n - 1)) \from *(pwcs + (0 .. n - 1)), n;
 */
extern size_t wcstombs(char *s, wchar_t const *pwcs, size_t n);

/*@ requires \valid_read((char *)s1 + (0 .. n - 1));
    requires \valid_read((char *)s2 + (0 .. n - 1));
    ensures
      \result ≡
      memcmp{Pre, Pre}((char *)\old(s1), (char *)\old(s2), \old(n));
    assigns \result;
    assigns \result
      \from *((char *)s1 + (0 .. n - 1)), *((char *)s2 + (0 .. n - 1));
 */
extern int memcmp(void const *s1, void const *s2, size_t n);

/*@ requires \valid_read((unsigned char *)s + (0 .. n - 1));
    assigns \result;
    assigns \result \from s, c, *((unsigned char *)s + (0 .. n - 1));
    
    behavior found:
      assumes memchr((char *)s, c, n) ≡ \true;
      ensures \base_addr(\result) ≡ \base_addr(\old(s));
      ensures (int)*((char *)\result) ≡ \old(c);
      ensures
        ∀ ℤ i;
          0 ≤ i < \old(n) ⇒
          *((unsigned char *)\old(s) + i) ≡ \old(c) ⇒
          \result ≤ \old(s) + i;
    
    behavior not_found:
      assumes ¬(memchr((char *)s, c, n) ≡ \true);
      ensures \result ≡ \null;
 */
extern void *memchr(void const *s, int c, size_t n);

/*@ requires valid_dst: \valid((char *)dest + (0 .. n - 1));
    requires valid_src: \valid_read((char *)src + (0 .. n - 1));
    requires
      \separated((char *)dest + (0 .. n - 1), (char *)src + (0 .. n - 1));
    ensures
      memcmp{Post, Pre}((char *)\old(dest), (char *)\old(src), \old(n)) ≡ 0;
    ensures \result ≡ \old(dest);
    assigns *((char *)dest + (0 .. n - 1)), \result;
    assigns *((char *)dest + (0 .. n - 1))
      \from *((char *)src + (0 .. n - 1));
    assigns \result \from dest;
 */
extern void *memcpy(void *dest, void const *src, size_t n);

/*@ requires valid_dst: \valid((char *)dest + (0 .. n - 1));
    requires valid_src: \valid_read((char *)src + (0 .. n - 1));
    ensures
      memcmp{Post, Pre}((char *)\old(dest), (char *)\old(src), \old(n)) ≡ 0;
    ensures \result ≡ \old(dest);
    assigns *((char *)dest + (0 .. n - 1)), \result;
    assigns *((char *)dest + (0 .. n - 1))
      \from *((char *)src + (0 .. n - 1));
    assigns \result \from dest;
 */
extern void *memmove(void *dest, void const *src, size_t n);

/*@ requires \valid((char *)s + (0 .. n - 1));
    ensures memset((char *)\old(s), \old(c), \old(n)) ≡ \true;
    ensures \result ≡ \old(s);
    assigns *((char *)s + (0 .. n - 1)), \result;
    assigns *((char *)s + (0 .. n - 1)) \from c;
    assigns \result \from s;
 */
extern void *memset(void *s, int c, size_t n);

/*@ requires valid_string_src: valid_read_string(s);
    ensures \result ≡ strlen(\old(s));
    assigns \result;
    assigns \result \from *(s + (0 ..));
 */
extern size_t strlen(char const *s);

/*@ requires valid_string_src: valid_read_string(s);
    ensures \result ≡ strlen(\old(s)) ∨ \result ≡ \old(n);
    assigns \result;
    assigns \result \from *(s + (0 ..));
 */
extern size_t strnlen(char const *s, size_t n);

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    ensures \result ≡ strcmp(\old(s1), \old(s2));
    assigns \result;
    assigns \result \from *(s1 + (0 ..)), *(s2 + (0 ..));
 */
extern int strcmp(char const *s1, char const *s2);

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    ensures \result ≡ strncmp(\old(s1), \old(s2), \old(n));
    assigns \result;
    assigns \result \from *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
 */
extern int strncmp(char const *s1, char const *s2, size_t n);

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    assigns \result;
    assigns \result \from *(s1 + (0 ..)), *(s2 + (0 ..));
 */
extern int strcoll(char const *s1, char const *s2);

/*@ requires valid_string_src: valid_read_string(s);
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), c;
    
    behavior found:
      assumes strchr(s, c) ≡ \true;
      ensures (int)*\result ≡ \old(c);
      ensures \base_addr(\result) ≡ \base_addr(\old(s));
      ensures \old(s) ≤ \result < \old(s) + strlen(\old(s));
      ensures valid_read_string(\result);
      ensures ∀ char *p; \old(s) ≤ p < \result ⇒ (int)*p ≢ \old(c);
    
    behavior not_found:
      assumes ¬(strchr(s, c) ≡ \true);
      ensures \result ≡ \null;
    
    behavior default:
      ensures
        \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
 */
extern char *strchr(char const *s, int c);

/*@ requires valid_string_src: valid_read_string(s);
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), c;
    
    behavior found:
      assumes strchr(s, c) ≡ \true;
      ensures (int)*\result ≡ \old(c);
      ensures \base_addr(\result) ≡ \base_addr(\old(s));
      ensures valid_read_string(\result);
    
    behavior not_found:
      assumes ¬(strchr(s, c) ≡ \true);
      ensures \result ≡ \null;
    
    behavior default:
      ensures
        \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
 */
extern char *strrchr(char const *s, int c);

/*@ requires valid_string_src: valid_read_string(s);
    requires valid_string_reject: valid_read_string(reject);
    ensures 0 ≤ \result ≤ strlen(\old(s));
    assigns \result;
    assigns \result \from *(s + (0 ..)), *(reject + (0 ..));
 */
extern size_t strcspn(char const *s, char const *reject);

/*@ requires valid_string_src: valid_read_string(s);
    requires valid_string_accept: valid_read_string(accept);
    ensures 0 ≤ \result ≤ strlen(\old(s));
    assigns \result;
    assigns \result \from *(s + (0 ..)), *(accept + (0 ..));
 */
extern size_t strspn(char const *s, char const *accept);

/*@ requires valid_string_src: valid_read_string(s);
    requires valid_string_accept: valid_read_string(accept);
    ensures
      \result ≡ (char *)0 ∨ \base_addr(\result) ≡ \base_addr(\old(s));
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), *(accept + (0 ..));
 */
extern char *strpbrk(char const *s, char const *accept);

/*@ requires valid_string_haystack: valid_read_string(haystack);
    requires valid_string_needle: valid_read_string(needle);
    ensures
      \result ≡ (char *)0 ∨
      (\subset(\result, \old(haystack) + (0 ..)) ∧ \valid_read(\result) ∧
       memcmp{Pre, Pre}(\result, \old(needle), strlen(\old(needle))) ≡ 0);
    assigns \result;
    assigns \result \from haystack, *(haystack + (0 ..)), *(needle + (0 ..));
 */
extern char *strstr(char const *haystack, char const *needle);

/*@ requires valid_string_src: valid_string_or_null(s);
    requires valid_string_delim: valid_read_string(delim);
    ensures
      \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), *(delim + (0 ..));
 */
extern char *strtok(char *s, char const *delim);

/*@ requires valid_string_src: \valid(stringp) ∧ valid_string(*stringp);
    requires valid_string_delim: valid_read_string(delim);
    assigns *stringp, \result;
    assigns *stringp \from *(delim + (..)), *(*(stringp + (..)));
    assigns \result \from *(delim + (..)), *(*(stringp + (..)));
 */
extern char *strsep(char **stringp, char const *delim);

/*@ ensures valid_read_string(\result);
    assigns \result;
    assigns \result \from errnum;
 */
extern char *strerror(int errnum);

/*@ requires valid_string_src: valid_read_string(src);
    requires room_string: \valid(dest + (0 .. strlen(src)));
    ensures strcmp(\old(dest), \old(src)) ≡ 0;
    ensures \result ≡ \old(dest);
    assigns *(dest + (0 .. strlen{Old}(src))), \result;
    assigns *(dest + (0 .. strlen{Old}(src)))
      \from *(src + (0 .. strlen{Old}(src)));
    assigns \result \from dest;
 */
extern char *strcpy(char *dest, char const *src);

/*@ requires valid_string_src: valid_read_string(src);
    requires room_nstring: \valid(dest + (0 .. n - 1));
    ensures \result ≡ \old(dest);
    ensures \initialized(\old(dest) + (0 .. \old(n) - 1));
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1)) \from *(src + (0 .. n - 1));
    assigns \result \from dest;
    
    behavior complete:
      assumes strlen(src) < n;
      ensures strcmp(\old(dest), \old(src)) ≡ 0;
    
    behavior partial:
      assumes n ≤ strlen(src);
      ensures memcmp{Post, Post}(\old(dest), \old(src), \old(n)) ≡ 0;
 */
extern char *strncpy(char *dest, char const *src, size_t n);

/*@ requires valid_string_src: valid_read_string(src);
    requires valid_string_dst: valid_string(dest);
    requires room_string: \valid(dest + (0 .. strlen(dest) + strlen(src)));
    ensures strlen(\old(dest)) ≡ \old(strlen(dest) + strlen(src));
    ensures \result ≡ \old(dest);
    assigns *(dest +
              (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src))),
            \result;
    assigns
    *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src)))
      \from *(src + (0 .. strlen{Old}(src)));
    assigns \result \from dest;
 */
extern char *strcat(char *dest, char const *src);

/*@ requires
      valid_string_src:
        valid_read_string(src) ∨ \valid_read(src + (0 .. n - 1));
    requires valid_string_dst: valid_string(dest);
    requires room_string: \valid(dest + (strlen(dest) .. strlen(dest) + n));
    ensures \result ≡ \old(dest);
    assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n)), \result;
    assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n))
      \from *(src + (0 .. n));
    assigns \result \from dest;
    
    behavior complete:
      assumes valid_read_string(src) ∧ strlen(src) ≤ n;
      ensures strlen(\old(dest)) ≡ \old(strlen(dest) + strlen(src));
      assigns *(dest +
                (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src))),
              \result;
      assigns
      *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src)))
        \from *(src + (0 .. strlen{Old}(src)));
      assigns \result \from dest;
    
    behavior partial:
      assumes ¬(valid_read_string(src) ∧ strlen(src) ≤ n);
      ensures strlen(\old(dest)) ≡ \old(strlen(dest)) + \old(n);
      assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n)),
              \result;
      assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n))
        \from *(src + (0 .. strlen{Old}(src)));
      assigns \result \from dest;
 */
extern char *strncat(char *dest, char const *src, size_t n);

/*@ requires valid_dest: \valid(dest + (0 .. n - 1));
    requires valid_string_src: valid_read_string(src);
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1)) \from *(src + (0 ..)), n;
    assigns \result \from dest;
 */
extern size_t strxfrm(char *dest, char const *src, size_t n);

/*@ requires valid_string_src: valid_read_string(s);
    ensures
      \valid(\result + (0 .. strlen(\old(s)))) ∧
      strcmp(\result, \old(s)) ≡ 0;
    assigns \nothing;
 */
extern char *strdup(char const *s);

/*@ requires valid_string_src: valid_read_string(s);
    ensures
      \valid(\result + (0 .. minimum(strlen(\old(s)), \old(n)))) ∧
      valid_string(\result) ∧ strlen(\result) ≤ \old(n) ∧
      strncmp(\result, \old(s), \old(n)) ≡ 0;
    assigns \nothing;
 */
extern char *strndup(char const *s, size_t n);

/*@ requires \valid((char *)s + (0 .. n - 1));
    assigns *((char *)s + (0 .. n - 1));
    assigns *((char *)s + (0 .. n - 1)) \from \nothing;
 */
extern void bzero(void *s, size_t n);

/*@ ghost unsigned int volatile __fc_time __attribute__((__FRAMA_C_MODEL__));
  */
/*@ assigns \result;
    assigns \result \from __fc_time; */
extern clock_t clock(void);

/*@ assigns \result;
    assigns \result \from time1, time0; */
extern double difftime(time_t time1, time_t time0);

/*@ assigns *timeptr, \result;
    assigns *timeptr \from *timeptr;
    assigns \result \from *timeptr;
 */
extern time_t mktime(struct tm *timeptr);

/*@ assigns *timer, \result;
    assigns *timer \from __fc_time;
    assigns \result \from __fc_time;
    
    behavior null:
      assumes timer ≡ \null;
      assigns \result;
      assigns \result \from __fc_time;
    
    behavior not_null:
      assumes timer ≢ \null;
      requires \valid(timer);
      ensures \initialized(\old(timer));
      assigns *timer, \result;
      assigns *timer \from __fc_time;
      assigns \result \from __fc_time;
    
    complete behaviors not_null, null;
    disjoint behaviors not_null, null;
 */
extern time_t time(time_t *timer);

struct tm __fc_time_tm;
struct tm * const __p_fc_time_tm = & __fc_time_tm;
/*@ ensures \result ≡ &__fc_time_tm ∨ \result ≡ \null;
    assigns \result, __fc_time_tm;
    assigns \result \from __p_fc_time_tm;
    assigns __fc_time_tm \from *timer;
 */
extern struct tm *gmtime(time_t const *timer);

/*@ ensures \result ≡ &__fc_time_tm ∨ \result ≡ \null;
    assigns \result, __fc_time_tm;
    assigns \result \from __p_fc_time_tm;
    assigns __fc_time_tm \from *timer;
 */
extern struct tm *localtime(time_t const *timer);

/*@ ensures
      \result ≡ \null ∨ \subset(\result, \old(s) + (0 .. \old(n) - 1));
    assigns \result;
    assigns \result
      \from s, (indirect: *(s + (0 .. n - 1))), (indirect: c), (indirect: n);
 */
extern wchar_t *wmemchr(wchar_t const *s, wchar_t c, size_t n);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 .. n - 1))),
            (indirect: *(s2 + (0 .. n - 1))), (indirect: n);
 */
extern int wmemcmp(wchar_t const *s1, wchar_t const *s2, size_t n);

/*@ requires \separated(dest + (0 .. n - 1), src + (0 .. n - 1));
    ensures \result ≡ \old(dest);
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from *(src + (0 .. n - 1)), (indirect: src), (indirect: n);
    assigns \result \from dest;
 */
extern wchar_t *wmemcpy(wchar_t *dest, wchar_t const *src, size_t n);

/*@ ensures \result ≡ \old(dest);
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from *(src + (0 .. n - 1)), (indirect: src), (indirect: n);
    assigns \result \from dest;
 */
extern wchar_t *wmemmove(wchar_t *dest, wchar_t const *src, size_t n);

/*@ ensures \result ≡ \old(wcs);
    assigns *(wcs + (0 .. n - 1)), \result;
    assigns *(wcs + (0 .. n - 1)) \from wc, (indirect: n);
    assigns \result \from wcs;
 */
extern wchar_t *wmemset(wchar_t *wcs, wchar_t wc, size_t n);

/*@ ensures \result ≡ \old(dest);
    assigns *(dest + (0 ..)), \result;
    assigns *(dest + (0 ..))
      \from *(dest + (0 ..)), (indirect: dest), *(src + (0 ..)),
            (indirect: src);
    assigns \result \from dest;
 */
extern wchar_t *wcscat(wchar_t *dest, wchar_t const *src);

/*@ ensures \result ≡ \null ∨ \subset(\result, \old(wcs) + (0 ..));
    assigns \result;
    assigns \result \from wcs, (indirect: wc);
 */
extern wchar_t *wcschr(wchar_t const *wcs, wchar_t wc);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 ..))), (indirect: *(s2 + (0 ..)));
 */
extern int wcscmp(wchar_t const *s1, wchar_t const *s2);

/*@ ensures \result ≡ \old(dest);
    assigns *(dest + (0 ..)), \result;
    assigns *(dest + (0 ..))
      \from *(src + (0 ..)), (indirect: src), *(dest + (0 ..)),
            (indirect: dest);
    assigns \result \from dest;
 */
extern wchar_t *wcscpy(wchar_t *dest, wchar_t const *src);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(wcs + (0 ..))), (indirect: *(accept + (0 ..)));
 */
extern size_t wcscspn(wchar_t const *wcs, wchar_t const *accept);

/*@ assigns *(dest + (0 ..)), \result;
    assigns *(dest + (0 ..))
      \from *(dest + (0 ..)), (indirect: dest), *(src + (0 .. n - 1)),
            (indirect: src), (indirect: n);
    assigns \result
      \from (indirect: *(dest + (0 ..))), (indirect: *(src + (0 .. n - 1))),
            (indirect: n);
 */
extern size_t wcslcat(wchar_t *dest, wchar_t const *src, size_t n);

/*@ requires \separated(dest + (0 .. n - 1), src + (0 .. n - 1));
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from *(src + (0 .. n - 1)), (indirect: src), (indirect: n);
    assigns \result
      \from (indirect: *(dest + (0 .. n - 1))), (indirect: dest),
            (indirect: *(src + (0 .. n - 1))), (indirect: src), (indirect: n);
 */
extern size_t wcslcpy(wchar_t *dest, wchar_t const *src, size_t n);

/*@ assigns \result;
    assigns \result \from (indirect: *(s + (0 ..))); */
extern size_t wcslen(wchar_t const *s);

/*@ ensures \result ≡ \old(dest);
    assigns *(dest + (0 ..)), \result;
    assigns *(dest + (0 ..))
      \from *(dest + (0 ..)), (indirect: dest), *(src + (0 .. n - 1)),
            (indirect: src), (indirect: n);
    assigns \result \from dest;
 */
extern wchar_t *wcsncat(wchar_t *dest, wchar_t const *src, size_t n);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 .. n - 1))),
            (indirect: *(s2 + (0 .. n - 1))), (indirect: n);
 */
extern int wcsncmp(wchar_t const *s1, wchar_t const *s2, size_t n);

/*@ requires \separated(dest + (0 .. n - 1), src + (0 .. n - 1));
    ensures \result ≡ \old(dest);
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from *(src + (0 .. n - 1)), (indirect: src), (indirect: n);
    assigns \result \from dest;
 */
extern wchar_t *wcsncpy(wchar_t *dest, wchar_t const *src, size_t n);

/*@ ensures \result ≡ \null ∨ \subset(\result, \old(wcs) + (0 ..));
    assigns \result;
    assigns \result
      \from wcs, (indirect: *(wcs + (0 ..))), (indirect: *(accept + (0 ..)));
 */
extern wchar_t *wcspbrk(wchar_t const *wcs, wchar_t const *accept);

/*@ ensures \result ≡ \null ∨ \subset(\result, \old(wcs) + (0 ..));
    assigns \result;
    assigns \result \from wcs, (indirect: *(wcs + (0 ..))), (indirect: wc);
 */
extern wchar_t *wcsrchr(wchar_t const *wcs, wchar_t wc);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(wcs + (0 ..))), (indirect: *(accept + (0 ..)));
 */
extern size_t wcsspn(wchar_t const *wcs, wchar_t const *accept);

/*@ ensures \result ≡ \null ∨ \subset(\result, \old(haystack) + (0 ..));
    assigns \result;
    assigns \result
      \from haystack, (indirect: *(haystack + (0 ..))),
            (indirect: *(needle + (0 ..)));
 */
extern wchar_t *wcsstr(wchar_t const *haystack, wchar_t const *needle);


[kernel] Parsing share/libc/__fc_builtin_for_normalization.i (no preprocessing)
[kernel] Parsing tests/spec/clash_double_file_bts1598.c (with preprocessing)
[kernel] Parsing tests/spec/result/foo.c (with preprocessing)
/* Generated by Frama-C */
typedef unsigned int size_t;
struct option {
   char const *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
typedef long long intmax_t;
struct __anonstruct_imaxdiv_t_1 {
   long long quot ;
   long long rem ;
};
typedef struct __anonstruct_imaxdiv_t_1 imaxdiv_t;
typedef int wchar_t;
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
typedef int jmp_buf[5];
typedef unsigned long sigset_t;
struct __anonstruct_sigjmp_buf_2 {
   jmp_buf buf ;
   sigset_t sigs ;
};
typedef struct __anonstruct_sigjmp_buf_2 sigjmp_buf;
typedef __builtin_va_list va_list;
typedef long time_t;
struct __fc_pos_t {
   unsigned long __fc_stdio_position ;
};
typedef struct __fc_pos_t fpos_t;
struct __fc_FILE {
   unsigned int __fc_FILE_id ;
   unsigned int __fc_FILE_data ;
};
typedef struct __fc_FILE FILE;
struct __fc_div_t {
   int quot ;
   int rem ;
};
typedef struct __fc_div_t div_t;
struct __fc_ldiv_t {
   long quot ;
   long rem ;
};
typedef struct __fc_ldiv_t ldiv_t;
struct __fc_lldiv_t {
   long long quot ;
   long long rem ;
};
typedef struct __fc_lldiv_t lldiv_t;
typedef unsigned int clock_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
};
extern int volatile Frama_C_entropy_source __attribute__((__unused__,
                                                          __FRAMA_C_MODEL__));

/*@ requires \valid(p + (0 .. l - 1));
    ensures \initialized(\old(p) + (0 .. \old(l) - 1));
    assigns *(p + (0 .. l - 1)), Frama_C_entropy_source;
    assigns *(p + (0 .. l - 1)) \from Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern void Frama_C_make_unknown(char *p, size_t l);

/*@ ensures \result ≡ \old(a) ∨ \result ≡ \old(b);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from a, b, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int Frama_C_nondet(int a, int b);

/*@ ensures \result ≡ \old(a) ∨ \result ≡ \old(b);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from a, b, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern void *Frama_C_nondet_ptr(void *a, void *b);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int Frama_C_interval(int min, int max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int Frama_C_interval_split(int min, int max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned char Frama_C_unsigned_char_interval(unsigned char min,
                                                    unsigned char max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern char Frama_C_char_interval(char min, char max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned short Frama_C_unsigned_short_interval(unsigned short min,
                                                      unsigned short max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern short Frama_C_short_interval(short min, short max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned int Frama_C_unsigned_int_interval(unsigned int min,
                                                  unsigned int max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int Frama_C_int_interval(int min, int max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned long Frama_C_unsigned_long_interval(unsigned long min,
                                                    unsigned long max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern long Frama_C_long_interval(long min, long max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned long long Frama_C_unsigned_long_long_interval(unsigned long long min,
                                                              unsigned long long max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern long long Frama_C_long_long_interval(long long min, long long max);

/*@ requires \is_finite(min) ∧ \is_finite(max);
    requires min ≤ max;
    ensures \is_finite(\result) ∧ \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern float Frama_C_float_interval(float min, float max);

/*@ requires \is_finite(min) ∧ \is_finite(max);
    requires min ≤ max;
    ensures \is_finite(\result) ∧ \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern double Frama_C_double_interval(double min, double max);

/*@ assigns *((char *)dest + (0 .. n - 1)), \result;
    assigns *((char *)dest + (0 .. n - 1))
      \from *((char *)src + (0 .. n - 1));
    assigns \result \from dest;
 */
extern void *Frama_C_memcpy(void *dest, void const *src, size_t n);

/*@ assigns *((char *)p + (0 .. s - 1)), \result;
    assigns *((char *)p + (0 .. s - 1)) \from c;
    assigns \result \from p;
 */
extern void *Frama_C_memset(void *p, int c, size_t s);

/*@ requires \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void Frama_C_abort(void);

/*@ assigns \result;
    assigns \result \from p; */
extern size_t Frama_C_offset(void const *p);

/*@ requires \false;
    terminates \false;
    assigns \nothing; */
extern void __FC_assert(char const *file, int line, char const *expr);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_not_match:
      assumes
        c ≡ -1 ∨ (0 ≤ c ≤ 47) ∨ (58 ≤ c ≤ 64) ∨
        (91 ≤ c ≤ 96) ∨ (123 ≤ c ≤ 127);
      ensures \result ≡ 0;
    
    behavior definitely_match:
      assumes
        ('A' ≤ c ≤ 'Z') ∨ ('a' ≤ c ≤ 'z') ∨ ('0' ≤ c ≤ '9');
      ensures \result < 0 ∨ \result > 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int isalnum(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_not_match:
      assumes
        c ≡ -1 ∨ (0 ≤ c ≤ 64) ∨ (91 ≤ c ≤ 96) ∨
        (123 ≤ c ≤ 127);
      ensures \result ≡ 0;
    
    behavior definitely_match:
      assumes ('A' ≤ c ≤ 'Z') ∨ ('a' ≤ c ≤ 'z');
      ensures \result < 0 ∨ \result > 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int isalpha(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior match:
      assumes c ≡ ' ' ∨ c ≡ '\t';
      ensures \result < 0 ∨ \result > 0;
    
    behavior no_match:
      assumes c ≢ ' ' ∧ c ≢ '\t';
      ensures \result ≡ 0;
    
    complete behaviors match, no_match;
    disjoint behaviors match, no_match;
 */
extern int isblank(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes (0 ≤ c ≤ 31) ∨ c ≡ 127;
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c ≡ -1 ∨ (32 ≤ c ≤ 126);
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int iscntrl(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior match:
      assumes '0' ≤ c ≤ '9';
      ensures \result < 0 ∨ \result > 0;
    
    behavior no_match:
      assumes c < '0' ∨ c > '9';
      ensures \result ≡ 0;
    
    complete behaviors match, no_match;
    disjoint behaviors match, no_match;
 */
extern int isdigit(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes 33 ≤ c ≤ 126;
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c ≡ -1 ∨ (0 ≤ c ≤ 32) ∨ c ≡ 127;
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int isgraph(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes 'a' ≤ c ≤ 'z';
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c ≡ -1 ∨ (0 ≤ c < 'a') ∨ ('z' < c < 127);
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int islower(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes 32 ≤ c ≤ 126;
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c ≡ -1 ∨ (0 ≤ c ≤ 31) ∨ c ≡ 127;
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int isprint(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes
        (33 ≤ c ≤ 47) ∨ (58 ≤ c ≤ 64) ∨ (91 ≤ c ≤ 96) ∨
        (123 ≤ c ≤ 126);
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes
        c ≡ -1 ∨ (0 ≤ c ≤ 32) ∨ (48 ≤ c ≤ 57) ∨
        (65 ≤ c ≤ 90) ∨ (97 ≤ c ≤ 122) ∨ c ≡ 127;
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int ispunct(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes (9 ≤ c ≤ 13) ∨ c ≡ ' ';
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes
        c ≡ -1 ∨ (0 ≤ c ≤ 8) ∨ (14 ≤ c < ' ') ∨
        (' ' < c ≤ 127);
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int isspace(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes 'A' ≤ c ≤ 'Z';
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c ≡ -1 ∨ (0 ≤ c < 'A') ∨ ('Z' < c ≤ 127);
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
extern int isupper(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior match:
      assumes
        ('0' ≤ c ≤ '9') ∨ ('A' ≤ c ≤ 'F') ∨ ('a' ≤ c ≤ 'f');
      ensures \result < 0 ∨ \result > 0;
    
    behavior no_match:
      assumes
        ¬(('0' ≤ c ≤ '9') ∨ ('A' ≤ c ≤ 'F') ∨
           ('a' ≤ c ≤ 'f'));
      ensures \result ≡ 0;
    
    complete behaviors match, no_match;
    disjoint behaviors match, no_match;
 */
extern int isxdigit(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    ensures (0 ≤ \result ≤ 255) ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_changed:
      assumes 'A' ≤ c ≤ 'Z';
      ensures \result ≡ \old(c) + 32;
    
    behavior definitely_not_changed:
      assumes c ≡ -1 ∨ (0 ≤ c < 'A') ∨ ('Z' < c ≤ 127);
      ensures \result ≡ \old(c);
    
    disjoint behaviors definitely_changed, definitely_not_changed;
 */
extern int tolower(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    ensures (0 ≤ \result ≤ 255) ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_changed:
      assumes 'a' ≤ c ≤ 'z';
      ensures \result ≡ \old(c) - 32;
    
    behavior definitely_not_changed:
      assumes c ≡ -1 ∨ (0 ≤ c < 'a') ∨ ('z' < c ≤ 127);
      ensures \result ≡ \old(c);
    
    disjoint behaviors definitely_changed, definitely_not_changed;
 */
extern int toupper(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior match:
      assumes 0 ≤ c ≤ 127;
      ensures \result < 0 ∨ \result > 0;
    
    behavior no_match:
      assumes ¬(0 ≤ c ≤ 127);
      ensures \result ≡ 0;
    
    complete behaviors match, no_match;
    disjoint behaviors match, no_match;
 */
extern int isascii(int c);

extern int __FC_errno;

extern char *optarg;

extern int optind;

extern int opterr;

extern int optopt;

/*@ assigns \result, *optarg, optind, opterr, optopt;
    assigns \result
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
    assigns *optarg
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
    assigns optind
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
    assigns opterr
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
    assigns optopt
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
 */
extern int getopt(int argc, char * const *argv, char const *optstring);

/*@ assigns \result, *optarg, optind, opterr, optopt,
            *((longopts + (0 ..))->flag);
    assigns \result
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns *optarg
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns optind
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns opterr
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns optopt
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns *((longopts + (0 ..))->flag)
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
 */
extern int getopt_long(int argc, char * const *argv, char const *shortopts,
                       struct option const *longopts, int *longind);

/*@ assigns \result, *optarg, optind, opterr, optopt,
            *((longopts + (0 ..))->flag);
    assigns \result
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns *optarg
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns optind
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns opterr
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns optopt
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns *((longopts + (0 ..))->flag)
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
 */
extern int getopt_long_only(int argc, char * const *argv,
                            char const *shortopts,
                            struct option const *longopts, int *longind);

/*@ requires (intmax_t)(-c) ≢ c;
    assigns \result;
    assigns \result \from c;
 */
extern intmax_t imaxabs(intmax_t c);

/*@ requires denom ≢ 0;
    ensures \result.quot ≡ \old(numer) / \old(denom);
    ensures \result.rem ≡ \old(numer) % \old(denom);
    assigns \result;
    assigns \result \from numer, denom;
 */
extern imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);

/*@ assigns \result, *(endptr + (..)), __FC_errno;
    assigns \result \from *(nptr + (..)), base;
    assigns *(endptr + (..)) \from *(nptr + (..)), base;
    assigns __FC_errno \from *(nptr + (..)), base;
 */
extern intmax_t strtoimax(char const *nptr, char **endptr, int base);

/*@
axiomatic MemCmp {
  logic ℤ memcmp{L1, L2}(char *s1, char *s2, ℤ n) 
    reads \at(*(s1 + (0 .. n - 1)),L1), \at(*(s2 + (0 .. n - 1)),L2);
  
  axiom memcmp_zero{L1, L2}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L1, L2}(s1, s2, n) ≡ 0 ⇔
      (∀ ℤ i; 0 ≤ i < n ⇒ \at(*(s1 + i),L1) ≡ \at(*(s2 + i),L2));
  
  }
 */
/*@
axiomatic MemChr {
  logic 𝔹 memchr{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom memchr_def{L}:
    ∀ char *s;
    ∀ ℤ c;
    ∀ ℤ n;
      memchr(s, c, n) ≡ \true ⇔
      (∃ int i; 0 ≤ i < n ∧ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic MemSet {
  logic 𝔹 memset{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom memset_def{L}:
    ∀ char *s;
    ∀ ℤ c;
    ∀ ℤ n;
      memset(s, c, n) ≡ \true ⇔
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic StrLen {
  logic ℤ strlen{L}(char *s) 
    reads *(s + (0 ..));
  
  axiom strlen_pos_or_null{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ∧ (∀ ℤ j; 0 ≤ j < i ⇒ *(s + j) ≢ '\000') ∧
      *(s + i) ≡ '\000' ⇒ strlen(s) ≡ i;
  
  axiom strlen_neg{L}:
    ∀ char *s;
      (∀ ℤ i; 0 ≤ i ⇒ *(s + i) ≢ '\000') ⇒ strlen(s) < 0;
  
  axiom strlen_before_null{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i < strlen(s) ⇒ *(s + i) ≢ '\000';
  
  axiom strlen_at_null{L}:
    ∀ char *s; 0 ≤ strlen(s) ⇒ *(s + strlen(s)) ≡ '\000';
  
  axiom strlen_not_zero{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ≤ strlen(s) ∧ *(s + i) ≢ '\000' ⇒ i < strlen(s);
  
  axiom strlen_zero{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ≤ strlen(s) ∧ *(s + i) ≡ '\000' ⇒ i ≡ strlen(s);
  
  axiom strlen_sup{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ∧ *(s + i) ≡ '\000' ⇒ 0 ≤ strlen(s) ≤ i;
  
  axiom strlen_shift{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ≤ strlen(s) ⇒ strlen(s + i) ≡ strlen(s) - i;
  
  axiom strlen_create{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ∧ *(s + i) ≡ '\000' ⇒ 0 ≤ strlen(s) ≤ i;
  
  axiom strlen_create_shift{L}:
    ∀ char *s;
    ∀ ℤ i;
    ∀ ℤ k;
      0 ≤ k ≤ i ∧ *(s + i) ≡ '\000' ⇒ 0 ≤ strlen(s + k) ≤ i - k;
  
  axiom memcmp_strlen_left{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L, L}(s1, s2, n) ≡ 0 ∧ strlen(s1) < n ⇒
      strlen(s1) ≡ strlen(s2);
  
  axiom memcmp_strlen_right{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L, L}(s1, s2, n) ≡ 0 ∧ strlen(s2) < n ⇒
      strlen(s1) ≡ strlen(s2);
  
  axiom memcmp_strlen_shift_left{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ k, ℤ n;
      memcmp{L, L}(s1, s2 + k, n) ≡ 0 ≤ k ∧ strlen(s1) < n ⇒
      0 ≤ strlen(s2) ≤ k + strlen(s1);
  
  axiom memcmp_strlen_shift_right{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ k, ℤ n;
      memcmp{L, L}(s1 + k, s2, n) ≡ 0 ≤ k ∧ strlen(s2) < n ⇒
      0 ≤ strlen(s1) ≤ k + strlen(s2);
  
  }
 */
/*@
axiomatic StrCmp {
  logic ℤ strcmp{L}(char *s1, char *s2) 
    reads *(s1 + (0 .. strlen(s1))), *(s2 + (0 .. strlen(s2)));
  
  axiom strcmp_zero{L}:
    ∀ char *s1, char *s2;
      strcmp(s1, s2) ≡ 0 ⇔
      strlen(s1) ≡ strlen(s2) ∧
      (∀ ℤ i; 0 ≤ i ≤ strlen(s1) ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic StrNCmp {
  logic ℤ strncmp{L}(char *s1, char *s2, ℤ n) 
    reads *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
  
  axiom strncmp_zero{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      strncmp(s1, s2, n) ≡ 0 ⇔
      (strlen(s1) < n ∧ strcmp(s1, s2) ≡ 0) ∨
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic StrChr {
  logic 𝔹 strchr{L}(char *s, ℤ c) 
    reads *(s + (0 .. strlen(s)));
  
  axiom strchr_def{L}:
    ∀ char *s;
    ∀ ℤ c;
      strchr(s, c) ≡ \true ⇔
      (∃ ℤ i; 0 ≤ i ≤ strlen(s) ∧ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic WcsLen {
  logic ℤ wcslen{L}(wchar_t *s) 
    reads *(s + (0 ..));
  
  axiom wcslen_pos_or_null{L}:
    ∀ wchar_t *s;
    ∀ ℤ i;
      0 ≤ i ∧ (∀ ℤ j; 0 ≤ j < i ⇒ *(s + j) ≢ 0) ∧
      *(s + i) ≡ 0 ⇒ wcslen(s) ≡ i;
  
  axiom wcslen_neg{L}:
    ∀ wchar_t *s; (∀ ℤ i; 0 ≤ i ⇒ *(s + i) ≢ 0) ⇒ wcslen(s) < 0;
  
  axiom wcslen_before_null{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i < wcslen(s) ⇒ *(s + i) ≢ 0;
  
  axiom wcslen_at_null{L}:
    ∀ wchar_t *s; 0 ≤ wcslen(s) ⇒ *(s + wcslen(s)) ≡ 0;
  
  axiom wcslen_not_zero{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ≤ wcslen(s) ∧ *(s + i) ≢ 0 ⇒ i < wcslen(s);
  
  axiom wcslen_zero{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ≤ wcslen(s) ∧ *(s + i) ≡ 0 ⇒ i ≡ wcslen(s);
  
  axiom wcslen_sup{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ∧ *(s + i) ≡ 0 ⇒ 0 ≤ wcslen(s) ≤ i;
  
  axiom wcslen_shift{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ≤ wcslen(s) ⇒ wcslen(s + i) ≡ wcslen(s) - i;
  
  axiom wcslen_create{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ∧ *(s + i) ≡ 0 ⇒ 0 ≤ wcslen(s) ≤ i;
  
  axiom wcslen_create_shift{L}:
    ∀ wchar_t *s;
    ∀ int i;
    ∀ int k;
      0 ≤ k ≤ i ∧ *(s + i) ≡ 0 ⇒ 0 ≤ wcslen(s + k) ≤ i - k;
  
  }
 */
/*@
axiomatic WcsCmp {
  logic ℤ wcscmp{L}(wchar_t *s1, wchar_t *s2) 
    reads *(s1 + (0 .. wcslen(s1))), *(s2 + (0 .. wcslen(s2)));
  
  axiom wcscmp_zero{L}:
    ∀ wchar_t *s1, wchar_t *s2;
      wcscmp(s1, s2) ≡ 0 ⇔
      wcslen(s1) ≡ wcslen(s2) ∧
      (∀ ℤ i; 0 ≤ i ≤ wcslen(s1) ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic WcsNCmp {
  logic ℤ wcsncmp{L}(wchar_t *s1, wchar_t *s2, ℤ n) 
    reads *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
  
  axiom wcsncmp_zero{L}:
    ∀ wchar_t *s1, wchar_t *s2;
    ∀ ℤ n;
      wcsncmp(s1, s2, n) ≡ 0 ⇔
      (wcslen(s1) < n ∧ wcscmp(s1, s2) ≡ 0) ∨
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@ logic ℤ minimum(ℤ i, ℤ j) = i < j? i: j;
 */
/*@ logic ℤ maximum(ℤ i, ℤ j) = i < j? j: i;
 */
/*@
predicate valid_string{L}(char *s) =
  0 ≤ strlen(s) ∧ \valid(s + (0 .. strlen(s)));
 */
/*@
predicate valid_read_string{L}(char *s) =
  0 ≤ strlen(s) ∧ \valid_read(s + (0 .. strlen(s)));
 */
/*@
predicate valid_string_or_null{L}(char *s) = s ≡ \null ∨ valid_string(s);
 */
/*@
predicate valid_wstring{L}(wchar_t *s) =
  0 ≤ wcslen(s) ∧ \valid(s + (0 .. wcslen(s)));
 */
/*@
predicate valid_wstring_or_null{L}(wchar_t *s) =
  s ≡ \null ∨ valid_wstring(s);
 */
extern struct lconv *__frama_c_locale;

extern char *__frama_c_locale_names[];

/*@ requires locale ≡ \null ∨ valid_read_string(locale);
    ensures
      \result ≡ \null ∨
      (\valid(\result) ∧ (∃ ℤ i; \result ≡ __frama_c_locale_names[i]));
    assigns __frama_c_locale, \result;
    assigns __frama_c_locale \from category, *(locale + (..));
    assigns \result \from __frama_c_locale, category, *(locale + (..));
 */
extern char *setlocale(int category, char const *locale);

/*@ ensures \result ≡ __frama_c_locale;
    assigns \nothing; */
extern struct lconv *localeconv(void);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, edom;
 */
extern double acos(double x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, edom;
 */
extern float acosf(float x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, edom;
 */
extern long double acosl(long double x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, edom;
 */
extern double asin(double x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, edom;
 */
extern float asinf(float x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, edom;
 */
extern long double asinl(long double x);

/*@ assigns \result;
    assigns \result \from y, x; */
extern double atan2(double y, double x);

/*@ assigns \result;
    assigns \result \from x; */
extern double cos(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern double sin(double x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ x ≥ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior infinite:
      assumes \is_plus_infinity(x);
      ensures \is_plus_infinity(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_minus_infinity(x) ∨ (\is_finite(x) ∧ x < 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, infinite, edom;
 */
extern double acosh(double x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ x ≥ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior infinite:
      assumes \is_plus_infinity(x);
      ensures \is_plus_infinity(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_minus_infinity(x) ∨ (\is_finite(x) ∧ x < 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, infinite, edom;
 */
extern float acoshf(float x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ x ≥ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior infinite:
      assumes \is_plus_infinity(x);
      ensures \is_plus_infinity(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_minus_infinity(x) ∨ (\is_finite(x) ∧ x < 1);
      ensures __FC_errno ≡ 1;
      assigns __FC_errno;
    
    disjoint behaviors normal, infinite, edom;
 */
extern long double acoshl(long double x);

/*@ assigns \result;
    assigns \result \from x; */
extern double exp(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float expf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double log(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float logf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double log10(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float log10f(float x);

/*@ assigns \result;
    assigns \result \from x, y; */
extern double pow(double x, double y);

/*@ assigns \result;
    assigns \result \from x, y; */
extern float powf(float x, float y);

/*@ assigns \result;
    assigns \result \from x; */
extern double sqrt(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float sqrtf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double ceil(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float ceilf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double floor(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float floorf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double round(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float roundf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double trunc(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float truncf(float x);

/*@ assigns \result;
    assigns \result \from x, y; */
extern double fmod(double x, double y);

/*@ requires valid_read_string(tagp);
    ensures \is_NaN(\result);
    assigns \nothing;
 */
extern double nan(char const *tagp);

/*@ requires valid_read_string(tagp);
    ensures \is_NaN(\result);
    assigns \nothing;
 */
extern float nanf(char const *tagp);

/*@ requires valid_read_string(tagp);
    ensures \is_NaN(\result);
    assigns \nothing;
 */
extern long double nanl(char const *tagp);

/*@ assigns *(env + (0 .. 4)); */
extern int setjmp(int * /*[5]*/ env);

/*@ ensures \false;
    assigns \nothing; */
extern void longjmp(int * /*[5]*/ env, int val);

/*@ ensures \false;
    assigns \nothing; */
extern void siglongjmp(sigjmp_buf env, int val);

/*@ assigns \nothing; */
extern void (*signal(int sig, void (*func)(int )))(int );

/*@ ensures \false;
    assigns \nothing; */
extern int raise(int sig);

extern FILE *__fc_stdin;

extern FILE *__fc_stdout;

/*@ assigns \nothing; */
extern int remove(char const *filename);

/*@ assigns \nothing; */
extern int rename(char const *old_name, char const *new_name);

/*@ ensures
      \result ≡ \null ∨
      (\valid(\result) ∧ \fresh{Old, Here}(\result,sizeof(FILE)));
    assigns \nothing;
 */
extern FILE *tmpfile(void);

/*@ assigns \result, *(s + (..));
    assigns \result \from *(s + (..));
    assigns *(s + (..)) \from \nothing;
 */
extern char *tmpnam(char *s);

/*@ requires \valid(stream);
    ensures \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from stream, stream->__fc_FILE_id;
 */
extern int fclose(FILE *stream);

/*@ requires stream ≡ \null ∨ \valid_read(stream);
    ensures \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from stream, stream->__fc_FILE_id;
 */
extern int fflush(FILE *stream);

FILE __fc_fopen[512];
FILE * const __p_fc_fopen = __fc_fopen;
/*@ ensures
      \result ≡ \null ∨ \subset(\result, &__fc_fopen[0 .. 512 - 1]);
    assigns \result;
    assigns \result \from *(filename + (..)), *(mode + (..)), __p_fc_fopen;
 */
extern FILE *fopen(char const *filename, char const *mode);

/*@ ensures
      \result ≡ \null ∨
      (\valid(\result) ∧ \fresh{Old, Here}(\result,sizeof(FILE)));
    assigns \result;
    assigns \result \from fildes, *(mode + (..));
 */
extern FILE *fdopen(int fildes, char const *mode);

/*@ ensures \result ≡ \null ∨ \result ≡ \old(stream);
    assigns *stream;
 */
extern FILE *freopen(char const *filename, char const *mode, FILE *stream);

/*@ assigns *stream;
    assigns *stream \from buf; */
extern void setbuf(FILE *stream, char *buf);

/*@ assigns *stream;
    assigns *stream \from buf, mode, size; */
extern int setvbuf(FILE *stream, char *buf, int mode, size_t size);

/*@ assigns *stream;
    assigns *stream \from stream->__fc_FILE_id; */
extern int fprintf(FILE *stream, char const *format , ...);

/*@ assigns *stream;
    assigns *stream \from stream->__fc_FILE_id; */
extern int fscanf(FILE *stream, char const *format , ...);

/*@ assigns *__fc_stdout;
    assigns *__fc_stdout \from *(format + (..)); */
extern int printf(char const *format , ...);

/*@ assigns *__fc_stdin; */
extern int scanf(char const *format , ...);

/*@ assigns *(s + (0 .. n - 1)); */
extern int snprintf(char *s, size_t n, char const *format , ...);

/*@ assigns *(s + (0 ..)); */
extern int sprintf(char *s, char const *format , ...);

/*@ assigns *stream;
    assigns *stream \from *(format + (..)), arg; */
extern int vfprintf(FILE *stream, char const *format, va_list arg);

/*@ assigns *stream;
    assigns *stream \from *(format + (..)), *stream; */
extern int vfscanf(FILE *stream, char const *format, va_list arg);

/*@ assigns *__fc_stdout;
    assigns *__fc_stdout \from arg; */
extern int vprintf(char const *format, va_list arg);

/*@ assigns *__fc_stdin;
    assigns *__fc_stdin \from *(format + (..)); */
extern int vscanf(char const *format, va_list arg);

/*@ assigns *(s + (0 .. n - 1));
    assigns *(s + (0 .. n - 1)) \from *(format + (..)), arg;
 */
extern int vsnprintf(char *s, size_t n, char const *format, va_list arg);

/*@ assigns *(s + (0 ..));
    assigns *(s + (0 ..)) \from *(format + (..)), arg;
 */
extern int vsprintf(char *s, char const *format, va_list arg);

/*@ assigns *stream; */
extern int fgetc(FILE *stream);

/*@ ensures \result ≡ \null ∨ \result ≡ \old(s);
    assigns *(s + (0 .. n - 1)), *stream, \result;
    assigns *(s + (0 .. n - 1)) \from *stream;
    assigns *stream \from *stream;
    assigns \result \from s, n, *stream;
 */
extern char *fgets(char *s, int n, FILE *stream);

/*@ assigns *stream; */
extern int fputc(int c, FILE *stream);

/*@ assigns *stream;
    assigns *stream \from *(s + (..)); */
extern int fputs(char const *s, FILE *stream);

/*@ assigns \result, *stream;
    assigns \result \from *stream;
    assigns *stream \from *stream;
 */
extern int getc(FILE *stream);

/*@ assigns \result;
    assigns \result \from *__fc_stdin; */
extern int getchar(void);

/*@ ensures \result ≡ \old(s) ∨ \result ≡ \null;
    assigns *(s + (..)), \result;
    assigns *(s + (..)) \from *__fc_stdin;
    assigns \result \from s, __fc_stdin;
 */
extern char *gets(char *s);

/*@ assigns *stream;
    assigns *stream \from c; */
extern int putc(int c, FILE *stream);

/*@ assigns *__fc_stdout;
    assigns *__fc_stdout \from c; */
extern int putchar(int c);

/*@ assigns *__fc_stdout;
    assigns *__fc_stdout \from *(s + (..)); */
extern int puts(char const *s);

/*@ assigns *stream;
    assigns *stream \from c; */
extern int ungetc(int c, FILE *stream);

/*@ requires \valid((char *)ptr + (0 .. nmemb * size - 1));
    requires \valid(stream);
    ensures \result ≤ \old(nmemb);
    ensures
      \initialized((char *)\old(ptr) + (0 .. \result * \old(size) - 1));
    assigns *((char *)ptr + (0 .. nmemb * size - 1)), \result;
    assigns *((char *)ptr + (0 .. nmemb * size - 1))
      \from size, nmemb, *stream;
    assigns \result \from size, *stream;
 */
extern size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);

/*@ requires \valid_read((char *)ptr + (0 .. nmemb * size - 1));
    requires \valid(stream);
    ensures \result ≤ \old(nmemb);
    assigns *stream, \result;
    assigns *stream \from *((char *)ptr + (0 .. nmemb * size - 1));
    assigns \result \from *((char *)ptr + (0 .. nmemb * size - 1));
 */
extern size_t fwrite(void const *ptr, size_t size, size_t nmemb, FILE *stream);

/*@ assigns *pos;
    assigns *pos \from *stream; */
extern int fgetpos(FILE *stream, fpos_t *pos);

/*@ assigns *stream, __FC_errno;
    assigns *stream \from offset, whence; */
extern int fseek(FILE *stream, long offset, int whence);

/*@ assigns *stream;
    assigns *stream \from *pos; */
extern int fsetpos(FILE *stream, fpos_t const *pos);

/*@ assigns \result, __FC_errno;
    assigns \result \from *stream;
    assigns __FC_errno \from *stream;
 */
extern long ftell(FILE *stream);

/*@ assigns *stream;
    assigns *stream \from \nothing; */
extern void rewind(FILE *stream);

/*@ assigns *stream;
    assigns *stream \from \nothing; */
extern void clearerr(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int feof(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int fileno(FILE *stream);

/*@ assigns *stream;
    assigns *stream \from \nothing; */
extern void flockfile(FILE *stream);

/*@ assigns *stream;
    assigns *stream \from \nothing; */
extern void funlockfile(FILE *stream);

/*@ assigns \result, *stream;
    assigns \result \from \nothing;
    assigns *stream \from \nothing;
 */
extern int ftrylockfile(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int ferror(FILE *stream);

/*@ assigns __fc_stdout;
    assigns __fc_stdout \from __FC_errno, *(s + (..));
 */
extern void perror(char const *s);

/*@ assigns \result, *stream;
    assigns \result \from *stream;
    assigns *stream \from *stream;
 */
extern int getc_unlocked(FILE *stream);

/*@ assigns \result;
    assigns \result \from *__fc_stdin; */
extern int getchar_unlocked(void);

/*@ assigns *stream;
    assigns *stream \from c; */
extern int putc_unlocked(int c, FILE *stream);

/*@ assigns *__fc_stdout;
    assigns *__fc_stdout \from c; */
extern int putchar_unlocked(int c);

/*@ assigns *stream;
    assigns *stream \from \nothing; */
extern void clearerr_unlocked(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int feof_unlocked(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int ferror_unlocked(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int fileno_unlocked(FILE *stream);

/*@ assigns \result;
    assigns \result \from *(nptr + (..)); */
extern double atof(char const *nptr);

/*@ assigns \result;
    assigns \result \from *(nptr + (..)); */
extern int atoi(char const *nptr);

/*@ assigns \result;
    assigns \result \from *(nptr + (..)); */
extern long atol(char const *nptr);

/*@ assigns \result;
    assigns \result \from *(nptr + (..)); */
extern long long atoll(char const *nptr);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr + (0 ..));
    assigns *endptr \from nptr, *(nptr + (0 ..));
 */
extern double strtod(char const *nptr, char **endptr);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr + (0 ..));
    assigns *endptr \from nptr, *(nptr + (0 ..));
 */
extern float strtof(char const *nptr, char **endptr);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr + (0 ..));
    assigns *endptr \from nptr, *(nptr + (0 ..));
 */
extern long double strtold(char const *nptr, char **endptr);

/*@ assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior null_endptr:
      assumes endptr ≡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior nonnull_endptr:
      assumes endptr ≢ \null;
      requires \valid(endptr);
      ensures \initialized(\old(endptr));
      ensures \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors nonnull_endptr, null_endptr;
    disjoint behaviors nonnull_endptr, null_endptr;
 */
extern long strtol(char const *nptr, char **endptr, int base);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr + (0 ..)), base;
    assigns *endptr \from nptr, *(nptr + (0 ..)), base;
 */
extern long long strtoll(char const *nptr, char **endptr, int base);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr + (0 ..)), base;
    assigns *endptr \from nptr, *(nptr + (0 ..)), base;
 */
extern unsigned long strtoul(char const *nptr, char **endptr, int base);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr + (0 ..)), base;
    assigns *endptr \from nptr, *(nptr + (0 ..)), base;
 */
extern unsigned long long strtoull(char const *nptr, char **endptr, int base);

/*@ ghost
  int __fc_random_counter __attribute__((__unused__, __FRAMA_C_MODEL__)); */
unsigned long const __fc_rand_max = (unsigned long)32767;
/*@ ensures 0 ≤ \result ≤ __fc_rand_max;
    assigns \result, __fc_random_counter;
    assigns \result \from __fc_random_counter;
    assigns __fc_random_counter \from __fc_random_counter;
 */
extern int rand(void);

/*@ assigns __fc_random_counter;
    assigns __fc_random_counter \from seed; */
extern void srand(unsigned int seed);

/*@ requires nmemb * size ≤ 4294967295U; */
extern void *calloc(size_t nmemb, size_t size);

/*@ ghost extern int __fc_heap_status __attribute__((__FRAMA_C_MODEL__)); */

/*@
axiomatic dynamic_allocation {
  predicate is_allocable{L}(size_t n) 
    reads __fc_heap_status;
  
  }
 */
/*@ assigns __fc_heap_status, \result;
    assigns __fc_heap_status \from size, __fc_heap_status;
    assigns \result \from (indirect: size), (indirect: __fc_heap_status);
    allocates \result;
    
    behavior allocation:
      assumes is_allocable(size);
      ensures \fresh{Old, Here}(\result,\old(size));
      assigns __fc_heap_status, \result;
      assigns __fc_heap_status \from size, __fc_heap_status;
      assigns \result \from (indirect: size), (indirect: __fc_heap_status);
    
    behavior no_allocation:
      assumes ¬is_allocable(size);
      ensures \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
extern void *malloc(size_t size);

/*@ assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status;
    frees p;
    
    behavior deallocation:
      assumes p ≢ \null;
      requires freeable: \freeable(p);
      ensures \allocable(\old(p));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status;
    
    behavior no_deallocation:
      assumes p ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_deallocation, deallocation;
    disjoint behaviors no_deallocation, deallocation;
 */
extern void free(void *p);

/*@ requires ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status, \result;
    assigns __fc_heap_status \from __fc_heap_status;
    assigns \result \from size, ptr, __fc_heap_status;
    frees ptr;
    allocates \result;
    
    behavior alloc:
      assumes is_allocable(size);
      ensures \fresh{Old, Here}(\result,\old(size));
      assigns \result;
      assigns \result \from size, __fc_heap_status;
      allocates \result;
    
    behavior dealloc:
      assumes ptr ≢ \null;
      assumes is_allocable(size);
      requires \freeable(ptr);
      ensures \allocable(\old(ptr));
      ensures \result ≡ \null ∨ \freeable(\result);
      frees ptr;
    
    behavior fail:
      assumes ¬is_allocable(size);
      ensures \result ≡ \null;
      assigns \result;
      assigns \result \from size, __fc_heap_status;
      allocates \nothing;
    
    complete behaviors fail, dealloc, alloc;
    disjoint behaviors alloc, fail;
    disjoint behaviors dealloc, fail;
 */
extern void *realloc(void *ptr, size_t size);

/*@ ensures \false;
    assigns \nothing; */
extern void abort(void);

/*@ assigns \result;
    assigns \result \from \nothing; */
extern int atexit(void (*func)(void));

/*@ assigns \result;
    assigns \result \from \nothing; */
extern int at_quick_exit(void (*func)(void));

/*@ ensures \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void exit(int status);

/*@ ensures \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void _Exit(int status);

/*@ ensures \result ≡ \null ∨ \valid(\result);
    assigns \result;
    assigns \result \from name;
 */
extern char *getenv(char const *name);

/*@ ensures \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void quick_exit(int status);

/*@ assigns \result;
    assigns \result \from *(string + (..)); */
extern int system(char const *string);

/*@ assigns *((char *)\result + (..));
    assigns *((char *)\result + (..))
      \from *((char *)key + (..)), *((char *)base + (..)), nmemb, size,
            *compar;
 */
extern void *bsearch(void const *key, void const *base, size_t nmemb,
                     size_t size, int (*compar)(void const *, void const *));

/*@ assigns *((char *)base + (..));
    assigns *((char *)base + (..))
      \from *((char *)base + (..)), nmemb, size, *compar;
 */
extern void qsort(void *base, size_t nmemb, size_t size,
                  int (*compar)(void const *, void const *));

/*@ requires abs_representable: (int)(-j) ≡ -j;
    assigns \result;
    assigns \result \from j;
 */
extern int abs(int j);

/*@ requires abs_representable: (long)(-j) ≡ -j;
    assigns \result;
    assigns \result \from j;
 */
extern long labs(long j);

/*@ requires abs_representable: (long long)(-j) ≡ -j;
    assigns \result;
    assigns \result \from j;
 */
extern long long llabs(long long j);

/*@ assigns \result;
    assigns \result \from numer, denom; */
extern div_t div(int numer, int denom);

/*@ assigns \result;
    assigns \result \from numer, denom; */
extern ldiv_t ldiv(long numer, long denom);

/*@ assigns \result;
    assigns \result \from numer, denom; */
extern lldiv_t lldiv(long long numer, long long denom);

/*@ assigns \result;
    assigns \result \from *(s + (0 ..)), n; */
extern int mblen(char const *s, size_t n);

/*@ assigns \result, *(pwc + (0 .. n - 1));
    assigns \result \from *(s + (0 .. n - 1)), n;
    assigns *(pwc + (0 .. n - 1)) \from *(s + (0 .. n - 1)), n;
 */
extern int mbtowc(wchar_t *pwc, char const *s, size_t n);

/*@ assigns \result, *(s + (0 ..));
    assigns \result \from wc;
    assigns *(s + (0 ..)) \from wc;
 */
extern int wctomb(char *s, wchar_t wc);

/*@ assigns \result, *(pwcs + (0 .. n - 1));
    assigns \result \from *(s + (0 .. n - 1)), n;
    assigns *(pwcs + (0 .. n - 1)) \from *(s + (0 .. n - 1)), n;
 */
extern size_t mbstowcs(wchar_t *pwcs, char const *s, size_t n);

/*@ assigns \result, *(s + (0 .. n - 1));
    assigns \result \from *(pwcs + (0 .. n - 1)), n;
    assigns *(s + (0 .. n - 1)) \from *(pwcs + (0 .. n - 1)), n;
 */
extern size_t wcstombs(char *s, wchar_t const *pwcs, size_t n);

/*@ requires \valid_read((char *)s1 + (0 .. n - 1));
    requires \valid_read((char *)s2 + (0 .. n - 1));
    ensures
      \result ≡
      memcmp{Pre, Pre}((char *)\old(s1), (char *)\old(s2), \old(n));
    assigns \result;
    assigns \result
      \from *((char *)s1 + (0 .. n - 1)), *((char *)s2 + (0 .. n - 1));
 */
extern int memcmp(void const *s1, void const *s2, size_t n);

/*@ requires \valid_read((unsigned char *)s + (0 .. n - 1));
    assigns \result;
    assigns \result \from s, c, *((unsigned char *)s + (0 .. n - 1));
    
    behavior found:
      assumes memchr((char *)s, c, n) ≡ \true;
      ensures \base_addr(\result) ≡ \base_addr(\old(s));
      ensures (int)*((char *)\result) ≡ \old(c);
      ensures
        ∀ ℤ i;
          0 ≤ i < \old(n) ⇒
          *((unsigned char *)\old(s) + i) ≡ \old(c) ⇒
          \result ≤ \old(s) + i;
    
    behavior not_found:
      assumes ¬(memchr((char *)s, c, n) ≡ \true);
      ensures \result ≡ \null;
 */
extern void *memchr(void const *s, int c, size_t n);

/*@ requires valid_dst: \valid((char *)dest + (0 .. n - 1));
    requires valid_src: \valid_read((char *)src + (0 .. n - 1));
    requires
      \separated((char *)dest + (0 .. n - 1), (char *)src + (0 .. n - 1));
    ensures
      memcmp{Post, Pre}((char *)\old(dest), (char *)\old(src), \old(n)) ≡ 0;
    ensures \result ≡ \old(dest);
    assigns *((char *)dest + (0 .. n - 1)), \result;
    assigns *((char *)dest + (0 .. n - 1))
      \from *((char *)src + (0 .. n - 1));
    assigns \result \from dest;
 */
extern void *memcpy(void *dest, void const *src, size_t n);

/*@ requires valid_dst: \valid((char *)dest + (0 .. n - 1));
    requires valid_src: \valid_read((char *)src + (0 .. n - 1));
    ensures
      memcmp{Post, Pre}((char *)\old(dest), (char *)\old(src), \old(n)) ≡ 0;
    ensures \result ≡ \old(dest);
    assigns *((char *)dest + (0 .. n - 1)), \result;
    assigns *((char *)dest + (0 .. n - 1))
      \from *((char *)src + (0 .. n - 1));
    assigns \result \from dest;
 */
extern void *memmove(void *dest, void const *src, size_t n);

/*@ requires \valid((char *)s + (0 .. n - 1));
    ensures memset((char *)\old(s), \old(c), \old(n)) ≡ \true;
    ensures \result ≡ \old(s);
    assigns *((char *)s + (0 .. n - 1)), \result;
    assigns *((char *)s + (0 .. n - 1)) \from c;
    assigns \result \from s;
 */
extern void *memset(void *s, int c, size_t n);

/*@ requires valid_string_src: valid_read_string(s);
    ensures \result ≡ strlen(\old(s));
    assigns \result;
    assigns \result \from *(s + (0 ..));
 */
extern size_t strlen(char const *s);

/*@ requires valid_string_src: valid_read_string(s);
    ensures \result ≡ strlen(\old(s)) ∨ \result ≡ \old(n);
    assigns \result;
    assigns \result \from *(s + (0 ..));
 */
extern size_t strnlen(char const *s, size_t n);

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    ensures \result ≡ strcmp(\old(s1), \old(s2));
    assigns \result;
    assigns \result \from *(s1 + (0 ..)), *(s2 + (0 ..));
 */
extern int strcmp(char const *s1, char const *s2);

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    ensures \result ≡ strncmp(\old(s1), \old(s2), \old(n));
    assigns \result;
    assigns \result \from *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
 */
extern int strncmp(char const *s1, char const *s2, size_t n);

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    assigns \result;
    assigns \result \from *(s1 + (0 ..)), *(s2 + (0 ..));
 */
extern int strcoll(char const *s1, char const *s2);

/*@ requires valid_string_src: valid_read_string(s);
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), c;
    
    behavior found:
      assumes strchr(s, c) ≡ \true;
      ensures (int)*\result ≡ \old(c);
      ensures \base_addr(\result) ≡ \base_addr(\old(s));
      ensures \old(s) ≤ \result < \old(s) + strlen(\old(s));
      ensures valid_read_string(\result);
      ensures ∀ char *p; \old(s) ≤ p < \result ⇒ (int)*p ≢ \old(c);
    
    behavior not_found:
      assumes ¬(strchr(s, c) ≡ \true);
      ensures \result ≡ \null;
    
    behavior default:
      ensures
        \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
 */
extern char *strchr(char const *s, int c);

/*@ requires valid_string_src: valid_read_string(s);
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), c;
    
    behavior found:
      assumes strchr(s, c) ≡ \true;
      ensures (int)*\result ≡ \old(c);
      ensures \base_addr(\result) ≡ \base_addr(\old(s));
      ensures valid_read_string(\result);
    
    behavior not_found:
      assumes ¬(strchr(s, c) ≡ \true);
      ensures \result ≡ \null;
    
    behavior default:
      ensures
        \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
 */
extern char *strrchr(char const *s, int c);

/*@ requires valid_string_src: valid_read_string(s);
    requires valid_string_reject: valid_read_string(reject);
    ensures 0 ≤ \result ≤ strlen(\old(s));
    assigns \result;
    assigns \result \from *(s + (0 ..)), *(reject + (0 ..));
 */
extern size_t strcspn(char const *s, char const *reject);

/*@ requires valid_string_src: valid_read_string(s);
    requires valid_string_accept: valid_read_string(accept);
    ensures 0 ≤ \result ≤ strlen(\old(s));
    assigns \result;
    assigns \result \from *(s + (0 ..)), *(accept + (0 ..));
 */
extern size_t strspn(char const *s, char const *accept);

/*@ requires valid_string_src: valid_read_string(s);
    requires valid_string_accept: valid_read_string(accept);
    ensures
      \result ≡ (char *)0 ∨ \base_addr(\result) ≡ \base_addr(\old(s));
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), *(accept + (0 ..));
 */
extern char *strpbrk(char const *s, char const *accept);

/*@ requires valid_string_haystack: valid_read_string(haystack);
    requires valid_string_needle: valid_read_string(needle);
    ensures
      \result ≡ (char *)0 ∨
      (\subset(\result, \old(haystack) + (0 ..)) ∧ \valid_read(\result) ∧
       memcmp{Pre, Pre}(\result, \old(needle), strlen(\old(needle))) ≡ 0);
    assigns \result;
    assigns \result \from haystack, *(haystack + (0 ..)), *(needle + (0 ..));
 */
extern char *strstr(char const *haystack, char const *needle);

/*@ requires valid_string_src: valid_string_or_null(s);
    requires valid_string_delim: valid_read_string(delim);
    ensures
      \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), *(delim + (0 ..));
 */
extern char *strtok(char *s, char const *delim);

/*@ requires valid_string_src: \valid(stringp) ∧ valid_string(*stringp);
    requires valid_string_delim: valid_read_string(delim);
    assigns *stringp, \result;
    assigns *stringp \from *(delim + (..)), *(*(stringp + (..)));
    assigns \result \from *(delim + (..)), *(*(stringp + (..)));
 */
extern char *strsep(char **stringp, char const *delim);

/*@ ensures valid_read_string(\result);
    assigns \result;
    assigns \result \from errnum;
 */
extern char *strerror(int errnum);

/*@ requires valid_string_src: valid_read_string(src);
    requires room_string: \valid(dest + (0 .. strlen(src)));
    ensures strcmp(\old(dest), \old(src)) ≡ 0;
    ensures \result ≡ \old(dest);
    assigns *(dest + (0 .. strlen{Old}(src))), \result;
    assigns *(dest + (0 .. strlen{Old}(src)))
      \from *(src + (0 .. strlen{Old}(src)));
    assigns \result \from dest;
 */
extern char *strcpy(char *dest, char const *src);

/*@ requires valid_string_src: valid_read_string(src);
    requires room_nstring: \valid(dest + (0 .. n - 1));
    ensures \result ≡ \old(dest);
    ensures \initialized(\old(dest) + (0 .. \old(n) - 1));
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1)) \from *(src + (0 .. n - 1));
    assigns \result \from dest;
    
    behavior complete:
      assumes strlen(src) < n;
      ensures strcmp(\old(dest), \old(src)) ≡ 0;
    
    behavior partial:
      assumes n ≤ strlen(src);
      ensures memcmp{Post, Post}(\old(dest), \old(src), \old(n)) ≡ 0;
 */
extern char *strncpy(char *dest, char const *src, size_t n);

/*@ requires valid_string_src: valid_read_string(src);
    requires valid_string_dst: valid_string(dest);
    requires room_string: \valid(dest + (0 .. strlen(dest) + strlen(src)));
    ensures strlen(\old(dest)) ≡ \old(strlen(dest) + strlen(src));
    ensures \result ≡ \old(dest);
    assigns *(dest +
              (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src))),
            \result;
    assigns
    *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src)))
      \from *(src + (0 .. strlen{Old}(src)));
    assigns \result \from dest;
 */
extern char *strcat(char *dest, char const *src);

/*@ requires
      valid_string_src:
        valid_read_string(src) ∨ \valid_read(src + (0 .. n - 1));
    requires valid_string_dst: valid_string(dest);
    requires room_string: \valid(dest + (strlen(dest) .. strlen(dest) + n));
    ensures \result ≡ \old(dest);
    assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n)), \result;
    assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n))
      \from *(src + (0 .. n));
    assigns \result \from dest;
    
    behavior complete:
      assumes valid_read_string(src) ∧ strlen(src) ≤ n;
      ensures strlen(\old(dest)) ≡ \old(strlen(dest) + strlen(src));
      assigns *(dest +
                (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src))),
              \result;
      assigns
      *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src)))
        \from *(src + (0 .. strlen{Old}(src)));
      assigns \result \from dest;
    
    behavior partial:
      assumes ¬(valid_read_string(src) ∧ strlen(src) ≤ n);
      ensures strlen(\old(dest)) ≡ \old(strlen(dest)) + \old(n);
      assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n)),
              \result;
      assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n))
        \from *(src + (0 .. strlen{Old}(src)));
      assigns \result \from dest;
 */
extern char *strncat(char *dest, char const *src, size_t n);

/*@ requires valid_dest: \valid(dest + (0 .. n - 1));
    requires valid_string_src: valid_read_string(src);
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1)) \from *(src + (0 ..)), n;
    assigns \result \from dest;
 */
extern size_t strxfrm(char *dest, char const *src, size_t n);

/*@ requires valid_string_src: valid_read_string(s);
    ensures
      \valid(\result + (0 .. strlen(\old(s)))) ∧
      strcmp(\result, \old(s)) ≡ 0;
    assigns \nothing;
 */
extern char *strdup(char const *s);

/*@ requires valid_string_src: valid_read_string(s);
    ensures
      \valid(\result + (0 .. minimum(strlen(\old(s)), \old(n)))) ∧
      valid_string(\result) ∧ strlen(\result) ≤ \old(n) ∧
      strncmp(\result, \old(s), \old(n)) ≡ 0;
    assigns \nothing;
 */
extern char *strndup(char const *s, size_t n);

/*@ requires \valid((char *)s + (0 .. n - 1));
    assigns *((char *)s + (0 .. n - 1));
    assigns *((char *)s + (0 .. n - 1)) \from \nothing;
 */
extern void bzero(void *s, size_t n);

/*@ ghost unsigned int volatile __fc_time __attribute__((__FRAMA_C_MODEL__));
  */
/*@ assigns \result;
    assigns \result \from __fc_time; */
extern clock_t clock(void);

/*@ assigns \result;
    assigns \result \from time1, time0; */
extern double difftime(time_t time1, time_t time0);

/*@ assigns *timeptr, \result;
    assigns *timeptr \from *timeptr;
    assigns \result \from *timeptr;
 */
extern time_t mktime(struct tm *timeptr);

/*@ assigns *timer, \result;
    assigns *timer \from __fc_time;
    assigns \result \from __fc_time;
    
    behavior null:
      assumes timer ≡ \null;
      assigns \result;
      assigns \result \from __fc_time;
    
    behavior not_null:
      assumes timer ≢ \null;
      requires \valid(timer);
      ensures \initialized(\old(timer));
      assigns *timer, \result;
      assigns *timer \from __fc_time;
      assigns \result \from __fc_time;
    
    complete behaviors not_null, null;
    disjoint behaviors not_null, null;
 */
extern time_t time(time_t *timer);

struct tm __fc_time_tm;
struct tm * const __p_fc_time_tm = & __fc_time_tm;
/*@ ensures \result ≡ &__fc_time_tm ∨ \result ≡ \null;
    assigns \result, __fc_time_tm;
    assigns \result \from __p_fc_time_tm;
    assigns __fc_time_tm \from *timer;
 */
extern struct tm *gmtime(time_t const *timer);

/*@ ensures \result ≡ &__fc_time_tm ∨ \result ≡ \null;
    assigns \result, __fc_time_tm;
    assigns \result \from __p_fc_time_tm;
    assigns __fc_time_tm \from *timer;
 */
extern struct tm *localtime(time_t const *timer);

/*@ ensures
      \result ≡ \null ∨ \subset(\result, \old(s) + (0 .. \old(n) - 1));
    assigns \result;
    assigns \result
      \from s, (indirect: *(s + (0 .. n - 1))), (indirect: c), (indirect: n);
 */
extern wchar_t *wmemchr(wchar_t const *s, wchar_t c, size_t n);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 .. n - 1))),
            (indirect: *(s2 + (0 .. n - 1))), (indirect: n);
 */
extern int wmemcmp(wchar_t const *s1, wchar_t const *s2, size_t n);

/*@ requires \separated(dest + (0 .. n - 1), src + (0 .. n - 1));
    ensures \result ≡ \old(dest);
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from *(src + (0 .. n - 1)), (indirect: src), (indirect: n);
    assigns \result \from dest;
 */
extern wchar_t *wmemcpy(wchar_t *dest, wchar_t const *src, size_t n);

/*@ ensures \result ≡ \old(dest);
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from *(src + (0 .. n - 1)), (indirect: src), (indirect: n);
    assigns \result \from dest;
 */
extern wchar_t *wmemmove(wchar_t *dest, wchar_t const *src, size_t n);

/*@ ensures \result ≡ \old(wcs);
    assigns *(wcs + (0 .. n - 1)), \result;
    assigns *(wcs + (0 .. n - 1)) \from wc, (indirect: n);
    assigns \result \from wcs;
 */
extern wchar_t *wmemset(wchar_t *wcs, wchar_t wc, size_t n);

/*@ ensures \result ≡ \old(dest);
    assigns *(dest + (0 ..)), \result;
    assigns *(dest + (0 ..))
      \from *(dest + (0 ..)), (indirect: dest), *(src + (0 ..)),
            (indirect: src);
    assigns \result \from dest;
 */
extern wchar_t *wcscat(wchar_t *dest, wchar_t const *src);

/*@ ensures \result ≡ \null ∨ \subset(\result, \old(wcs) + (0 ..));
    assigns \result;
    assigns \result \from wcs, (indirect: wc);
 */
extern wchar_t *wcschr(wchar_t const *wcs, wchar_t wc);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 ..))), (indirect: *(s2 + (0 ..)));
 */
extern int wcscmp(wchar_t const *s1, wchar_t const *s2);

/*@ ensures \result ≡ \old(dest);
    assigns *(dest + (0 ..)), \result;
    assigns *(dest + (0 ..))
      \from *(src + (0 ..)), (indirect: src), *(dest + (0 ..)),
            (indirect: dest);
    assigns \result \from dest;
 */
extern wchar_t *wcscpy(wchar_t *dest, wchar_t const *src);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(wcs + (0 ..))), (indirect: *(accept + (0 ..)));
 */
extern size_t wcscspn(wchar_t const *wcs, wchar_t const *accept);

/*@ assigns *(dest + (0 ..)), \result;
    assigns *(dest + (0 ..))
      \from *(dest + (0 ..)), (indirect: dest), *(src + (0 .. n - 1)),
            (indirect: src), (indirect: n);
    assigns \result
      \from (indirect: *(dest + (0 ..))), (indirect: *(src + (0 .. n - 1))),
            (indirect: n);
 */
extern size_t wcslcat(wchar_t *dest, wchar_t const *src, size_t n);

/*@ requires \separated(dest + (0 .. n - 1), src + (0 .. n - 1));
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from *(src + (0 .. n - 1)), (indirect: src), (indirect: n);
    assigns \result
      \from (indirect: *(dest + (0 .. n - 1))), (indirect: dest),
            (indirect: *(src + (0 .. n - 1))), (indirect: src), (indirect: n);
 */
extern size_t wcslcpy(wchar_t *dest, wchar_t const *src, size_t n);

/*@ assigns \result;
    assigns \result \from (indirect: *(s + (0 ..))); */
extern size_t wcslen(wchar_t const *s);

/*@ ensures \result ≡ \old(dest);
    assigns *(dest + (0 ..)), \result;
    assigns *(dest + (0 ..))
      \from *(dest + (0 ..)), (indirect: dest), *(src + (0 .. n - 1)),
            (indirect: src), (indirect: n);
    assigns \result \from dest;
 */
extern wchar_t *wcsncat(wchar_t *dest, wchar_t const *src, size_t n);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 .. n - 1))),
            (indirect: *(s2 + (0 .. n - 1))), (indirect: n);
 */
extern int wcsncmp(wchar_t const *s1, wchar_t const *s2, size_t n);

/*@ requires \separated(dest + (0 .. n - 1), src + (0 .. n - 1));
    ensures \result ≡ \old(dest);
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from *(src + (0 .. n - 1)), (indirect: src), (indirect: n);
    assigns \result \from dest;
 */
extern wchar_t *wcsncpy(wchar_t *dest, wchar_t const *src, size_t n);

/*@ ensures \result ≡ \null ∨ \subset(\result, \old(wcs) + (0 ..));
    assigns \result;
    assigns \result
      \from wcs, (indirect: *(wcs + (0 ..))), (indirect: *(accept + (0 ..)));
 */
extern wchar_t *wcspbrk(wchar_t const *wcs, wchar_t const *accept);

/*@ ensures \result ≡ \null ∨ \subset(\result, \old(wcs) + (0 ..));
    assigns \result;
    assigns \result \from wcs, (indirect: *(wcs + (0 ..))), (indirect: wc);
 */
extern wchar_t *wcsrchr(wchar_t const *wcs, wchar_t wc);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(wcs + (0 ..))), (indirect: *(accept + (0 ..)));
 */
extern size_t wcsspn(wchar_t const *wcs, wchar_t const *accept);

/*@ ensures \result ≡ \null ∨ \subset(\result, \old(haystack) + (0 ..));
    assigns \result;
    assigns \result
      \from haystack, (indirect: *(haystack + (0 ..))),
            (indirect: *(needle + (0 ..)));
 */
extern wchar_t *wcsstr(wchar_t const *haystack, wchar_t const *needle);


