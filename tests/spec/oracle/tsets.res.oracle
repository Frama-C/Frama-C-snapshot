[kernel] Parsing tests/spec/tsets.c (with preprocessing)
[kernel:annot-error] tests/spec/tsets.c:36: Warning: 
  sets of sets are not supported yet. Ignoring global annotation
[kernel:annot-error] tests/spec/tsets.c:46: Warning: 
  comparison of incompatible types: set<char>
   and ℤ. Ignoring global annotation
[kernel:annot-error] tests/spec/tsets.c:47: Warning: 
  comparison of incompatible types: set<char>
   and ℤ. Ignoring global annotation
[kernel:annot-error] tests/spec/tsets.c:48: Warning: 
  comparison of incompatible types: ℤ and set<char>
  . Ignoring global annotation
[kernel:annot-error] tests/spec/tsets.c:49: Warning: 
  comparison of incompatible types: ℤ and set<char>
  . Ignoring global annotation
[kernel:annot-error] tests/spec/tsets.c:56: Warning: 
  set of sets is not yet implemented. Ignoring global annotation
[kernel:annot-error] tests/spec/tsets.c:57: Warning: 
  set of sets is not yet implemented. Ignoring global annotation
/* Generated by Frama-C */
struct foo {
   char bar[4] ;
};
typedef char baz[4];
struct bli {
   baz bli ;
};
/*@ assigns x->bar[0 .. 3];
    assigns x->bar[0 .. 3] \from x->bar[0 .. 3]; */
int f(struct foo *x);

/*@ assigns *(x + (0 .. 3));
    assigns *(x + (0 .. 3)) \from y->bli[0 .. 3]; */
int g(char * /*[4]*/ x, struct bli *y);

int main(void)
{
  int __retres;
  struct foo x;
  baz y;
  struct bli z;
  f(& x);
  g(y,& z);
  /*@ assert \separated(&x, &y[2]); */ ;
  __retres = 0;
  return __retres;
}

/*@
predicate test1(set<int>  s1, set<int>  s2) =
  \subset(s1, \union(s2, {k + 1 | int k; constraint: 0 ≤ k < 10}));
 */
/*@
predicate test2(set<int>  s1, set<int>  s2) =
  \subset(\union({k + 1 | int k; constraint: 0 ≤ k < 10}, s2), s1);

*/
/*@ ensures \subset(\result, {\old(x), \old(x) + 1, \old(x) - 1});
    ensures \result ∈ {\old(x), \old(x) + 1, \old(x) - 1};
 */
int h(int x, int c)
{
  int tmp_0;
  if (c > 0) tmp_0 = x + 1;
  else {
    int tmp;
    if (c < 0) tmp = x - 1; else tmp = x;
    tmp_0 = tmp;
  }
  return tmp_0;
}

/*@ requires \valid(\union(*(a + (0 .. 1)), *(b + (0 .. 1)))); */
int foo(int **a, int **b)
{
  int __retres;
  __retres = 0;
  return __retres;
}

/*@
predicate test_singleton_1{L}(int *a, int x) = \at(x ≡ *(a + (0 .. 1)),L);
 */
/*@ predicate test_singleton_2{L}(int *a) = \at(*(a + (0 .. 1)) ≡ 1,L);
 */
/*@ predicate test_singleton_3{L}(int *a) = \at(*(a + (0 .. 1)) ≡ {1},L);
 */
/*@
predicate test_set_of_elem{L}(int *a) = \at(*(a + (0 .. 1)) ≡ {1, 2},L);

*/
int A[100];
/*@ ensures \subset(\result, &A[0 ..]);
    ensures \result ∈ &A[0 ..]; */
int *AA(void);

/*@ logic set<ℤ>  Sempty_1= \empty;
 */
/*@ logic set<ℤ>  Sempty_2= \empty;
 */
/*@ logic set<ℤ>  Selems_1= {1, 2, (int)'3'};
 */
/*@ logic set<ℤ>  Sadd_elem_1(set<ℤ>  s, ℤ e) = \union(s, e);
 */
/*@ logic set<ℤ>  Sadd_elem_2(set<ℤ>  s, ℤ e) = \union(s, {e});

*/

