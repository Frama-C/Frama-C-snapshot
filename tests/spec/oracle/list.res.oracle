[kernel] Parsing tests/spec/list.i (no preprocessing)
/* Generated by Frama-C */
/*@ type List<A> = \list<A> ;
 */
/*@ logic List<ℤ>  \empty_integer_list= [| |];
 */
/*@ predicate is_empty_list_1(\list<ℤ>  l1) = l1 ≡ [| |];
 */
/*@ predicate is_empty_list_2(\list<ℤ>  l1) = l1 ≡ [| |];
 */
/*@ predicate is_empty_list_3(\list<ℤ>  l1) = l1 ≡ \empty_integer_list;
 */
/*@ logic \list<ℤ>  empty_1= [| |];
 */
/*@ logic \list<ℤ>  empty_2= [| |];
 */
/*@ logic \list<ℤ>  empty_3= \empty_integer_list;
 */
/*@ logic \list<\list<ℤ> >  list_of_list_1= [| [| |] |];
 */
/*@ logic \list<ℤ>  call_to_1(ℤ id) = [| id |];
 */
/*@ logic \list<ℤ>  call_to_2(ℤ id) = [| id |];
 */
/*@ logic \list<ℤ>  call_to_3(ℤ id) = \Cons(id, \empty_integer_list);
 */
/*@ logic \list<ℤ>  list_1(int e1, ℤ e2) = [| e1, e2 |];
 */
/*@ logic \list<ℤ>  list_2(ℤ e1, ℤ e2) = [| e1, e2 |];
 */
/*@
logic \list<ℤ>  list_3(ℤ e1, ℤ e2) =
  \Cons(e1, \Cons(e2, \empty_integer_list));
 */
/*@
logic \list<ℤ>  concat_1(\list<ℤ>  seq1, \list<ℤ>  seq2) = seq1 ^ seq2;
 */
/*@
logic \list<ℤ>  concat_2(\list<ℤ>  seq1, \list<ℤ>  seq2) = seq1 ^ seq2;
 */
/*@ logic \list<ℤ>  repeat_1(\list<ℤ>  seq, ℤ n) = seq *^ n;
 */
/*@ logic \list<ℤ>  repeat_2(\list<ℤ>  seq, ℤ n) = seq *^ n;
 */
/*@
logic \list<ℤ>  add_call_to_1(ℤ id, \list<ℤ>  seq) = seq ^ [| id |];
 */
/*@
logic \list<ℤ>  add_call_to_2(ℤ id, \list<ℤ>  seq) = seq ^ [| id |];
 */
/*@
logic \list<ℤ>  add_call_to_3(ℤ id, \list<ℤ>  seq) =
  seq ^ call_to_1(id);
 */
/*@
predicate Padd_id{L1, L2}(ℤ id, \list<ℤ>  seq) =
  \at(seq,L1) ≡ (\at(seq,L2) ^ [| id |]);
 */
/*@
predicate Prepeat{L1, L2}(ℤ times, \list<ℤ>  seq) =
  \at(seq,L1) ≡ (\at(seq,L2) *^ times);
 */
/*@ ghost int seq; */
/*@ axiomatic Ghost {
      logic \list<ℤ>  ghost_seq{L}
        reads seq;
      
      }
 */
/*@ ensures Padd_id{Here, Pre}(\old(id), ghost_seq);
    assigns seq; */
void add_id(int id);

/*@ lemma length{L}: \length(ghost_seq) ≥ 0;
 */
/*@ lemma nth{L}: \nth(\Cons(1, ghost_seq), 0) ≡ 1;
 */

