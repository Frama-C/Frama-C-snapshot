[kernel] Parsing share/libc/__fc_builtin_for_normalization.i (no preprocessing)
[kernel] Parsing tests/spec/all.c (with preprocessing)
tests/spec/all.c:32:[kernel] warning: Inconsistent relation chain.
tests/spec/all.c:50:[kernel] warning: Assignment operators not allowed in annotations.
tests/spec/all.c:54:[kernel] warning: reference to unknown behavior ZZZ_INEXISTENT_BEHAVIOR. Ignoring code annotation
tests/spec/all.c:83:[kernel] warning: Global variable x is not a function. It cannot have a contract (ignoring).
/* Generated by Frama-C */
struct st {
   int a ;
   int b ;
};
/*@ lemma z: ∀ int x; (x&x) ≡ x;
 */
/*@ lemma a: ∀ int x; (~x|x) ≡ -1;
 */
/*@ lemma b: ∀ int x; (~x^x) ≡ -1;
 */
/*@ lemma c: (\let x = 0; x+1) ≡ 1;
 */
/*@ lemma d: (name: 77) ≡ 76+1;
 */
/*@
axiomatic Test {
  predicate P;
  
  predicate Q;
  
  axiom e: P ⊻ Q;
  
  axiom f: 0≢0? P: Q;
  
  axiom g: (P ⇒ P) ∧ (¬P ⇒ Q);
  
  axiom h: \let x = 0; x+1 ≡ 1;
  
  axiom i: name: 77 ≡ 76+1;
  
  }
 */
/*@ predicate R(ℤ i, ℤ j) = (1≢0? i+j: (j: j)) ≡ i+j;
 */
/*@ predicate S(ℤ i, ℤ j) = (1≢0? (i: j): j) ≡ j;
 */
/*@ predicate T(ℤ i, ℤ j) = (1≢0? i: j) ≡ i;
 */
/*@ lemma tauto: 0≢0? T(0, 0): R(1, 2);
 */
/*@ lemma tauto2: (R(0, 1) ⇒ S(3, 4)) ∧ (¬R(0, 1) ⇒ T(5, 6));
 */
/*@ lemma hex_oct: 0xFFFFUl ≢ 06666uL;
 */
/*@ requires \offset(p) ≡ 0;
    
    behavior b:
      assumes \true;
      requires \valid(p);
      ensures 0 ≡ 1;
      assigns *p;
      assigns *p \from G;
 */
extern void h(int G, int *p);

void f(int G, int *p)
{
  /*@ assert \false; */ ;
  /*@ assert \base_addr(&G) ≡ \base_addr(&G); */ ;
  /*@ assert \block_length(&G) ≡ 4; */ ;
  /*@ assert \block_length(&G) ≡ sizeof(G); */ ;
  /*@ assert \base_addr(&G)+\offset(&G+4) ≡ (char *)(&G+4); */ ;
  /*@ assert \null ≢ &G; */ ;
  /*@ loop invariant &G ≢ \null; */
  while (1) {
    G ++;
    break;
  }
  *p = G + 76;
  return;
}

/*@ axiomatic St {
      logic struct st fl(struct st s) ;
      
      }

*/
/*@ ensures (\let tmp = fl(\old(s)); tmp.a) ≡ \result.a; */
struct st fc(struct st s)
{
  return s;
}

void fd(char *x_0)
{
  /*@ assert (char const *)x_0 ≡ (char *)x_0; */ ;
  x_0 = (char *)"abcdef";
  /*@ assert ¬\valid(x_0) ∧ \valid_read(x_0); */ ;
  return;
}

int x = 0;
/*@ logic ℤ x= 1;
 */
/*@ axiomatic Test2 {
      logic ℤ y;
      
      }
 */
/*@ logic ℤ z= \let f = \lambda ℤ a; a+1; f(12);
 */
/*@ logic a id<a>(a x) = x;
 */
/*@ logic ℤ z1= \max(5, 10, id);
 */
/*@ logic ℤ z2= \min(5, 10, id);
 */
/*@ logic ℤ z3= \sum(5, 10, id);
 */
/*@ logic ℤ z4= \product(5, 10, id);
 */
/*@ logic ℤ z5= \numof(0, 10, \lambda ℤ i; 3 ≤ i ≤ 5);

*/

