[kernel] Parsing share/libc/__fc_builtin_for_normalization.i (no preprocessing)
[kernel] Parsing tests/spec/acsl_basic_allocator.c (with preprocessing)
/* Generated by Frama-C */
typedef unsigned int size_t;
typedef int wchar_t;
struct __fc_div_t {
   int quot ;
   int rem ;
};
typedef struct __fc_div_t div_t;
struct __fc_ldiv_t {
   long quot ;
   long rem ;
};
typedef struct __fc_ldiv_t ldiv_t;
struct __fc_lldiv_t {
   long long quot ;
   long long rem ;
};
typedef struct __fc_lldiv_t lldiv_t;
enum _bool {
    false = 0,
    true = 1
};
typedef enum _bool bool;
struct _memory_block {
   size_t size ;
   bool free ;
   char *data ;
};
typedef struct _memory_block memory_block;
struct _memory_block_list {
   memory_block *block ;
   struct _memory_block_list *next ;
};
typedef struct _memory_block_list memory_block_list;
typedef memory_block_list *memory_pool;
/*@ assigns \result;
    assigns \result \from *(nptr+(..)); */
extern double atof(char const *nptr);

/*@ assigns \result;
    assigns \result \from *(nptr+(..)); */
extern int atoi(char const *nptr);

/*@ assigns \result;
    assigns \result \from *(nptr+(..)); */
extern long atol(char const *nptr);

/*@ assigns \result;
    assigns \result \from *(nptr+(..)); */
extern long long atoll(char const *nptr);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr+(0 ..));
    assigns *endptr \from nptr, *(nptr+(0 ..));
 */
extern double strtod(char const *nptr, char **endptr);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr+(0 ..));
    assigns *endptr \from nptr, *(nptr+(0 ..));
 */
extern float strtof(char const *nptr, char **endptr);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr+(0 ..));
    assigns *endptr \from nptr, *(nptr+(0 ..));
 */
extern long double strtold(char const *nptr, char **endptr);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr+(0 ..)), base;
    assigns *endptr \from nptr, *(nptr+(0 ..)), base;
 */
extern long strtol(char const *nptr, char **endptr, int base);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr+(0 ..)), base;
    assigns *endptr \from nptr, *(nptr+(0 ..)), base;
 */
extern long long strtoll(char const *nptr, char **endptr, int base);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr+(0 ..)), base;
    assigns *endptr \from nptr, *(nptr+(0 ..)), base;
 */
extern unsigned long strtoul(char const *nptr, char **endptr, int base);

/*@ assigns \result, *endptr;
    assigns \result \from *(nptr+(0 ..)), base;
    assigns *endptr \from nptr, *(nptr+(0 ..)), base;
 */
extern unsigned long long strtoull(char const *nptr, char **endptr, int base);

/*@ ghost
  int __fc_random_counter __attribute__((__unused__, __FRAMA_C_MODEL__)); */
unsigned long const __fc_rand_max = (unsigned long)32767;
/*@ ensures 0 ≤ \result ≤ __fc_rand_max;
    assigns \result, __fc_random_counter;
    assigns \result \from __fc_random_counter;
    assigns __fc_random_counter \from __fc_random_counter;
 */
extern int rand(void);

/*@ assigns __fc_random_counter;
    assigns __fc_random_counter \from seed; */
extern void srand(unsigned int seed);

/*@ ghost extern int __fc_heap_status __attribute__((__FRAMA_C_MODEL__)); */

/*@
axiomatic dynamic_allocation {
  predicate is_allocable{L}(size_t n) 
    reads __fc_heap_status;
  
  }
 */
/*@ assigns __fc_heap_status, \result;
    assigns __fc_heap_status \from size, __fc_heap_status;
    assigns \result \from size, __fc_heap_status;
    allocates \result;
    
    behavior allocation:
      assumes is_allocable(size);
      ensures \fresh{Old, Here}(\result,\old(size));
      assigns __fc_heap_status, \result;
      assigns __fc_heap_status \from size, __fc_heap_status;
      assigns \result \from size, __fc_heap_status;
    
    behavior no_allocation:
      assumes ¬is_allocable(size);
      ensures \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
extern void *malloc(size_t size);

/*@ assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status;
    frees p;
    
    behavior deallocation:
      assumes p ≢ \null;
      requires freeable: \freeable(p);
      ensures \allocable(\old(p));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status;
    
    behavior no_deallocation:
      assumes p ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_deallocation, deallocation;
    disjoint behaviors no_deallocation, deallocation;
 */
extern void free(void *p);

/*@ requires ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status, \result;
    assigns __fc_heap_status \from __fc_heap_status;
    assigns \result \from size, ptr, __fc_heap_status;
    frees ptr;
    allocates \result;
    
    behavior alloc:
      assumes is_allocable(size);
      ensures \fresh{Old, Here}(\result,\old(size));
      assigns \result;
      assigns \result \from size, __fc_heap_status;
      allocates \result;
    
    behavior dealloc:
      assumes ptr ≢ \null;
      assumes is_allocable(size);
      requires \freeable(ptr);
      ensures \allocable(\old(ptr));
      ensures \result ≡ \null ∨ \freeable(\result);
      frees ptr;
    
    behavior fail:
      assumes ¬is_allocable(size);
      ensures \result ≡ \null;
      assigns \result;
      assigns \result \from size, __fc_heap_status;
      allocates \nothing;
    
    complete behaviors fail, dealloc, alloc;
    disjoint behaviors alloc, fail;
    disjoint behaviors dealloc, fail;
 */
extern void *realloc(void *ptr, size_t size);

/*@ ensures \false;
    assigns \nothing; */
extern void abort(void);

/*@ assigns \result;
    assigns \result \from \nothing; */
extern int atexit(void (*func)(void));

/*@ assigns \result;
    assigns \result \from \nothing; */
extern int at_quick_exit(void (*func)(void));

/*@ ensures \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void exit(int status);

/*@ ensures \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void _Exit(int status);

/*@ ensures \result ≡ \null ∨ \valid(\result);
    assigns \result;
    assigns \result \from name;
 */
extern char *getenv(char const *name);

/*@ ensures \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void quick_exit(int status);

/*@ assigns \result;
    assigns \result \from *(string+(..)); */
extern int system(char const *string);

/*@ assigns *((char *)\result+(..));
    assigns *((char *)\result+(..))
      \from *((char *)key+(..)), *((char *)base+(..)), nmemb, size, *compar;
 */
extern void *bsearch(void const *key, void const *base, size_t nmemb,
                     size_t size, int (*compar)(void const *, void const *));

/*@ assigns *((char *)base+(..));
    assigns *((char *)base+(..))
      \from *((char *)base+(..)), nmemb, size, *compar;
 */
extern void qsort(void *base, size_t nmemb, size_t size,
                  int (*compar)(void const *, void const *));

/*@ requires abs_representable: (int)(-j) ≡ -j;
    assigns \result;
    assigns \result \from j;
 */
extern int abs(int j);

/*@ requires abs_representable: (long)(-j) ≡ -j;
    assigns \result;
    assigns \result \from j;
 */
extern long labs(long j);

/*@ requires abs_representable: (long long)(-j) ≡ -j;
    assigns \result;
    assigns \result \from j;
 */
extern long long llabs(long long j);

/*@ assigns \result;
    assigns \result \from numer, denom; */
extern div_t div(int numer, int denom);

/*@ assigns \result;
    assigns \result \from numer, denom; */
extern ldiv_t ldiv(long numer, long denom);

/*@ assigns \result;
    assigns \result \from numer, denom; */
extern lldiv_t lldiv(long long numer, long long denom);

/*@ assigns \result;
    assigns \result \from *(s+(0 ..)), n; */
extern int mblen(char const *s, size_t n);

/*@ assigns \result, *(pwc+(0 .. n-1));
    assigns \result \from *(s+(0 .. n-1)), n;
    assigns *(pwc+(0 .. n-1)) \from *(s+(0 .. n-1)), n;
 */
extern int mbtowc(wchar_t *pwc, char const *s, size_t n);

/*@ assigns \result, *(s+(0 ..));
    assigns \result \from wc;
    assigns *(s+(0 ..)) \from wc;
 */
extern int wctomb(char *s, wchar_t wc);

/*@ assigns \result, *(pwcs+(0 .. n-1));
    assigns \result \from *(s+(0 .. n-1)), n;
    assigns *(pwcs+(0 .. n-1)) \from *(s+(0 .. n-1)), n;
 */
extern size_t mbstowcs(wchar_t *pwcs, char const *s, size_t n);

/*@ assigns \result, *(s+(0 .. n-1));
    assigns \result \from *(pwcs+(0 .. n-1)), n;
    assigns *(s+(0 .. n-1)) \from *(pwcs+(0 .. n-1)), n;
 */
extern size_t wcstombs(char *s, wchar_t const *pwcs, size_t n);

/*@
type invariant inv_memory_block(memory_block mb) =
  0 < mb.size ∧ \offset(mb.data) ≡ 0 ∧
  \block_length(mb.data) ≡ mb.size;
 */
/*@
predicate used_memory_block{L}(memory_block mb) =
  mb.free ≡ false ∧ inv_memory_block(mb);
 */
/*@
predicate freed_memory_block{L}(memory_block mb) =
  mb.free ≡ true ∧ inv_memory_block(mb);
 */
/*@
predicate valid_memory_block{L}(memory_block *mb) =
  \valid(mb) ∧ inv_memory_block(*mb);
 */
/*@
predicate valid_used_memory_block{L}(memory_block *mb) =
  \valid(mb) ∧ used_memory_block(*mb);
 */
/*@
predicate valid_freed_memory_block{L}(memory_block *mb) =
  \valid(mb) ∧ freed_memory_block(*mb);
 */
/*@
predicate valid_memory_block_list{L}(memory_block_list *mbl) =
  \valid(mbl) ∧ valid_memory_block(mbl->block) ∧
  (mbl->next ≡ \null ∨ valid_memory_block_list(mbl->next));
 */
/*@
predicate valid_memory_pool{L}(memory_pool *mp) =
  \valid(mp) ∧ valid_memory_block_list(*mp);
 */
/*@ requires valid_memory_pool(arena) ∧ 0 < s;
    ensures valid_used_memory_block(\result);
 */
memory_block *memory_alloc(memory_pool *arena, size_t s)
{
  memory_block *__retres;
  memory_block_list *mbl;
  memory_block *mb;
  size_t mb_size;
  char *mb_data;
  mbl = *arena;
  while (mbl != (memory_block_list *)0) {
    mb = mbl->block;
    if (mb->free) 
      if (s <= mb->size) {
        mb->free = false;
        __retres = mb;
        goto return_label;
      }
    mbl = mbl->next;
  }
  if ((size_t)1000 < s) mb_size = s; else mb_size = (unsigned int)1000;
  mb_data = (char *)malloc(mb_size);
  mb = (memory_block *)malloc(sizeof(memory_block));
  mb->size = mb_size;
  mb->free = false;
  mb->data = mb_data;
  mbl = (memory_block_list *)malloc(sizeof(memory_block_list));
  mbl->block = mb;
  mbl->next = *arena;
  *arena = mbl;
  __retres = mb;
  return_label: return __retres;
}

/*@ requires valid_memory_pool(arena) ∧ valid_used_memory_block(block);
    ensures valid_freed_memory_block(\old(block));
 */
void memory_free(memory_pool *arena, memory_block *block)
{
  block->free = true;
  return;
}


