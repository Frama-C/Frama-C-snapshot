[kernel] Parsing tests/constant_propagation/const_propagate.c (with preprocessing)
[scf] beginning constant propagation
[value] Analyzing a complete application starting at init
[value] Computing initial state
[value] Initial state computed
[value:initial-state] Values of globals at initialization
  x ∈ {0}
  y ∈ {0}
  z ∈ {0}
  TAB[0..9] ∈ {0}
  s1 ∈ {0}
  s2 ∈ {0}
  ull ∈ {0}
  f0 ∈ {0}
  f1 ∈ {0}
  f2 ∈ {0}
  f3 ∈ {0}
  d0 ∈ {0}
  d1 ∈ {0}
  d2 ∈ {0}
  d3 ∈ {0}
[value] computing for function add3 <- init.
  Called from tests/constant_propagation/const_propagate.c:56.
[value:alarm] tests/constant_propagation/const_propagate.c:48: Warning: 
  signed overflow. assert v1 + v2 ≤ 2147483647;
[value] Recording results for add3
[value] Done for function add3
[value] Recording results for init
[value] done for function init
/* Generated by Frama-C */
struct st {
   int a ;
   int b ;
};
typedef struct st ST;
int x;
int y;
int z;
int TAB[10];
struct st s1;
struct st s2;
void test_struct(void)
{
  ST s = {.a = 0, .b = 1};
  s1 = s;
  (s1.a) ++;
  s2.a = s1.a;
  (s.a) ++;
  s2 = s;
  (s.b) --;
  return;
}

void test_tab(int v)
{
  (s2.b) ++;
  TAB[s1.b] = TAB[s2.b];
  int *r = & TAB[4];
  *r = v;
  *(r + 1) = v;
  char *q = (char *)r;
  *q = (char)v;
  *(q + 1) = (char)v;
  int decal = (int)sizeof(int);
  *(q + decal) = (char)v;
  return;
}

int *test_ptr(int v)
{
  int *__retres;
  int *p = & x;
  char *s = (char *)p;
  *s = (char)v;
  int decal = 1;
  *(s + decal) = (char)v;
  s = (char *)p + decal;
  *s = (char)v;
  *p = v;
  __retres = & x;
  return __retres;
}

int *test_struct_ptr(void)
{
  int *__retres;
  int *q = & s1.b;
  __retres = & s1.a;
  return __retres;
}

int add3(int v1, int v2, int v3)
{
  int __retres;
  /*@ assert Value: signed_overflow: v1 + v2 ≤ 2147483647; */
  __retres = (v1 + 7) + 0;
  return __retres;
}

int init(int v)
{
  int zero = 0;
  int sept = 7;
  x = v;
  y = sept;
  z = add3(x,y,zero);
  int z1 = z;
  return zero;
}

unsigned long long ull;
void test_ull(void)
{
  ull -= (unsigned long long)1L;
  return;
}

float f0;
float f1;
float f2;
float f3;
double d0;
double d1;
double d2;
double d3;
void test_float_double(void)
{
  d1 = d0;
  d2 = d1 + d0;
  d3 = d2 + 1.0;
  f1 = f0;
  f2 = f1 + f0;
  f3 = (float)((double)f2 + 1.0);
  return;
}

void main(int a)
{
  int *tmp_1;
  test_ull();
  test_struct();
  test_struct_ptr();
  test_tab(13);
  test_float_double();
  int b = init(5);
  z = add3(a,0,0);
  int *p = test_ptr(y);
  /*@ assert *p ≡ 7; */ ;
  if (a) tmp_1 = p; else tmp_1 = & y;
  int *q = tmp_1;
  int yy = *q;
  /*@ assert a ≡ 0 ⇒ q ≡ &y; */ ;
  /*@ assert *q ≡ 7; */ ;
  return;
}


[scf] constant propagation done
