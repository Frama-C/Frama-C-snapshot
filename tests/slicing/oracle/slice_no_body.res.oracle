[kernel] Parsing share/libc/__fc_builtin_for_normalization.i (no preprocessing)
[kernel] Parsing tests/slicing/slice_no_body.c (with preprocessing)
[value] Analyzing an incomplete application starting at h
[value] Computing initial state
[value] Initial state computed
[value] Values of globals at initialization
  G ∈ [--..--]
[value] computing for function f <- h.
        Called from tests/slicing/slice_no_body.c:21.
tests/slicing/slice_no_body.c:21:[kernel] warning: Neither code nor specification for function f, generating default assigns from the prototype
[value] using specification for function f
[value] Done for function f
[value] computing for function f <- h.
        Called from tests/slicing/slice_no_body.c:22.
[value] Done for function f
[value] computing for function f <- h.
        Called from tests/slicing/slice_no_body.c:23.
[value] Done for function f
[value] computing for function f <- h.
        Called from tests/slicing/slice_no_body.c:24.
[value] Done for function f
[value] computing for function g <- h.
        Called from tests/slicing/slice_no_body.c:26.
tests/slicing/slice_no_body.c:12:[kernel] warning: signed overflow. assert c+1 ≤ 2147483647;
tests/slicing/slice_no_body.c:13:[kernel] warning: signed overflow. assert -2147483648 ≤ c*2;
tests/slicing/slice_no_body.c:13:[kernel] warning: signed overflow. assert c*2 ≤ 2147483647;
[value] computing for function f <- g <- h.
        Called from tests/slicing/slice_no_body.c:15.
[value] Done for function f
[value] Recording results for g
[value] Done for function g
[value] Recording results for h
[value] done for function h
[from] Computing for function g
[from] Computing for function f <-g
[from] Done for function f
[from] Done for function g
[from] Computing for function h
[from] Done for function h
[from] ====== DEPENDENCIES COMPUTED ======
       These dependencies hold at termination for the executions that terminate:
[from] Function f:
  \result FROM a
[from] Function g:
  \result FROM c
[from] Function h:
  G FROM \nothing
  \result FROM \nothing
[from] ====== END OF DEPENDENCIES ======
[slicing] making slicing project 'slicing_1'...
[pdg] computing for function h
[pdg] done for function h
[pdg] computing for function g
[pdg] done for function g
int G;
/*@ assigns \result;
    assigns \result \from a; */
extern int f(int a);

Print slice = g_slice_1: 

/**/int g(/* <[---], [---]> */ int c)
{
  /* <[---], [---]> */ int __retres;
  /* <[---], [---]> */ int x;
  /* <[---], [---]> */ int y;
  /*@ assert Value: signed_overflow: c+1 ≤ 2147483647; */
  /* <[---], [---]> */
  x = c + 1;
  /*@ assert Value: signed_overflow: -2147483648 ≤ c*2; */
  /*@ assert Value: signed_overflow: c*2 ≤ 2147483647; */
  /* <[---], [---]> */
  y = c * 2;
  /* <[---], [---]> */
  if (c == 0) {
    /* <[---], [---]> */ int tmp;
    /* invisible call */ /* <[---], [---]> */
    tmp = f(x);
    /* <[---], [---]> */
    __retres = tmp;
    /* <[---], [---]> */
    goto return_label;
  }
  else {
    /* <[---], [---]> */
    __retres = y;
    /* <[---], [---]> */
    goto return_label;
  }
  /* <[---], [---]> */ return_label: /* <[---], [---]> */
                                     return __retres;
}

Print slice = h_slice_1: 

/**/int h(void)
{
  /* <[---], [---]> */ int __retres;
  /* <[---], [---]> */ int a;
  /* <[---], [---]> */ int b;
  /* <[---], [---]> */ int c;
  /* invisible call */ /* <[---], [---]> */
  a = f(1);
  /* invisible call */ /* <[---], [---]> */
  b = f(2);
  /* invisible call */ /* <[---], [---]> */
  c = f(3);
  /* invisible call */ /* <[---], [---]> */
  G = f(4);
  /* <[---], [---]> */
  if (G > 0) {
    /* invisible call */ /* <[---], [---]> */
    G = g(c);
  }
  /* <[---], [---]> */
  __retres = (int)(& g);
  /* <[---], [---]> */
  return __retres;
}

Slicing project worklist [default/slicing_1] =
[h_slice_1 = change_call for call 18 -> g_slice_1][g_slice_1 = change_call for call 7 -> (src:f)][h_slice_1 = change_call for call 15 -> (src:f)][h_slice_1 = change_call for call 14 -> (src:f)][h_slice_1 = change_call for call 13 -> (src:f)][h_slice_1 = change_call for call 12 -> (src:f)]

[slicing] exporting project to 'Sliced code'...
[slicing] applying all slicing requests...
[slicing] applying 6 actions...
[slicing] applying actions: 1/6...
[slicing] applying actions: 2/6...
[slicing] applying actions: 3/6...
[slicing] applying actions: 4/6...
[slicing] applying actions: 5/6...
[slicing] applying actions: 6/6...
[sparecode] remove unused global declarations from project 'Sliced code tmp'
[sparecode] removed unused global declarations in new project 'Sliced code'
/* Generated by Frama-C */
int G;
extern int f(int a);

void g_slice_1(int c)
{
  int x;
  x = c + 1;
  if (c == 0) {
    int tmp;
    tmp = f(x);
  }
  return;
}

void h(void)
{
  int a;
  int b;
  int c;
  a = f(1);
  b = f(2);
  c = f(3);
  G = f(4);
  if (G > 0) g_slice_1(c);
  return;
}


[slicing] making slicing project 'slicing_2'...
[slicing] applying all slicing requests...
[slicing] applying 6 actions...
[slicing] applying actions: 1/6...
[slicing] applying actions: 2/6...
[slicing] applying actions: 3/6...
[slicing] applying actions: 4/6...
[slicing] applying actions: 5/6...
[slicing] applying actions: 6/6...
int G;
/*@ assigns \result;
    assigns \result \from a; */
extern int f(int a);

Print slice = g_slice_1: (InCtrl: <[---], [ S ]>)
                         (In1: <[---], [ S ]>)

/**/int g(/* <[---], [ S ]> */ int c)
{
  /* <[---], [---]> */ int __retres;
  /* <[---], [ S ]> */ int x;
  /* <[---], [---]> */ int y;
  /*@ assert Value: signed_overflow: c+1 ≤ 2147483647; */
  /* <[---], [ S ]> */
  x = c + 1;
  /*@ assert Value: signed_overflow: -2147483648 ≤ c*2; */
  /*@ assert Value: signed_overflow: c*2 ≤ 2147483647; */
  /* <[---], [---]> */
  y = c * 2;
  /* <[---], [ S ]> */
  if (c == 0) {
    /* <[---], [ S ]> */ int tmp;
    /* sig call:
      (InCtrl: <[---], [ S ]>)
      (In1: <[---], [ S ]>)
      (OutRet: <[---], [ S ]>) */
    /* call to source function */
    /* <[---], [ S ]> */
    tmp = f(x);
    /* <[---], [---]> */
    __retres = tmp;
    /* <[---], [---]> */
    goto return_label;
  }
  else {
    /* <[---], [---]> */
    __retres = y;
    /* <[---], [---]> */
    goto return_label;
  }
  /* <[---], [---]> */ return_label: /* <[---], [---]> */
                                     return __retres;
}

Print slice = h_slice_1: (InCtrl: <[---], [ S ]>)

/**/int h(void)
{
  /* <[---], [---]> */ int __retres;
  /* <[---], [ S ]> */ int a;
  /* <[---], [ S ]> */ int b;
  /* <[---], [ S ]> */ int c;
  /* sig call:
    (InCtrl: <[---], [ S ]>)
    (In1: <[---], [ S ]>)
    (OutRet: <[---], [ S ]>) */
  /* call to source function */
  /* <[---], [ S ]> */
  a = f(1);
  /* sig call:
    (InCtrl: <[---], [ S ]>)
    (In1: <[---], [ S ]>)
    (OutRet: <[---], [ S ]>) */
  /* call to source function */
  /* <[---], [ S ]> */
  b = f(2);
  /* sig call:
    (InCtrl: <[---], [ S ]>)
    (In1: <[---], [ S ]>)
    (OutRet: <[---], [ S ]>) */
  /* call to source function */
  /* <[---], [ S ]> */
  c = f(3);
  /* sig call:
    (InCtrl: <[---], [ S ]>)
    (In1: <[---], [ S ]>)
    (OutRet: <[---], [ S ]>) */
  /* call to source function */
  /* <[---], [ S ]> */
  G = f(4);
  /* <[---], [ S ]> */
  if (G > 0) {
    /* sig call: (InCtrl: <[---], [ S ]>)
                 (In1: <[---], [ S ]>) */
    /* call to g_slice_1: (InCtrl: <[---], [ S ]>)
                          (In1: <[---], [ S ]>) */
    /* <[---], [ S ]> */
    G = g(c);
  }
  /* <[---], [---]> */
  __retres = (int)(& g);
  /* <[---], [---]> */
  return __retres;
}

Slicing project worklist [default/slicing_2] =


[slicing] exporting project to 'Sliced code'...
[slicing] applying all slicing requests...
[slicing] applying 0 actions...
[sparecode] remove unused global declarations from project 'Sliced code tmp'
[sparecode] removed unused global declarations in new project 'Sliced code'
/* Generated by Frama-C */
int G;
extern int f(int a);

void g_slice_1(int c)
{
  int x;
  x = c + 1;
  if (c == 0) {
    int tmp;
    tmp = f(x);
  }
  return;
}

void h(void)
{
  int a;
  int b;
  int c;
  a = f(1);
  b = f(2);
  c = f(3);
  G = f(4);
  if (G > 0) g_slice_1(c);
  return;
}


