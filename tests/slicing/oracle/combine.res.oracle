[kernel] Parsing share/libc/__fc_builtin_for_normalization.i (no preprocessing)
[kernel] Parsing tests/slicing/combine.c (with preprocessing)
[value] Analyzing a complete application starting at main
[value] Computing initial state
[value] Initial state computed
[value] Values of globals at initialization
  
[value] computing for function f <- main.
        Called from tests/slicing/combine.c:24.
[value] computing for function g <- f <- main.
        Called from tests/slicing/combine.c:17.
[value] using specification for function g
[value] Done for function g
[value] Recording results for f
[value] Done for function f
[value] computing for function f <- main.
        Called from tests/slicing/combine.c:26.
[value] computing for function g <- f <- main.
        Called from tests/slicing/combine.c:17.
[value] Done for function g
[value] Recording results for f
[value] Done for function f
[value] Recording results for main
[value] done for function main
[from] Computing for function f
[from] Computing for function g <-f
[from] Done for function g
[from] Done for function f
[from] Computing for function main
[from] Done for function main
[from] ====== DEPENDENCIES COMPUTED ======
       These dependencies hold at termination for the executions that terminate:
[from] Function g:
  \result FROM x
[from] Function f:
  \result FROM c; x
[from] Function main:
  \result FROM x
[from] ====== END OF DEPENDENCIES ======
[slicing] making slicing project 'slicing_1'...
[pdg] computing for function main
[pdg] done for function main
[slicing] applying all slicing requests...
[slicing] applying 1 actions...
[slicing] applying actions: 1/1...
[pdg] computing for function f
[pdg] done for function f
[slicing] exporting project to 'Sliced code'...
[slicing] applying all slicing requests...
[slicing] applying 0 actions...
[sparecode] remove unused global declarations from project 'Sliced code tmp'
[sparecode] removed unused global declarations in new project 'Sliced code'
/* Generated by Frama-C */
extern int g(int x);

int f_slice_1(int c, int x)
{
  int y;
  int tmp;
  int r;
  if (c) tmp = 1; else tmp = -1;
  y = tmp;
  if (y < 0) r = x + y; else r = 0;
  r = g(r);
  return r;
}

int main(int x)
{
  int r;
  if (x > 0) r = f_slice_1(0,x); else r = f_slice_1(1,x);
  return r;
}


Let's split 'f':
[slicing] applying all slicing requests...
[slicing] applying 1 actions...
[slicing] applying actions: 1/1...
[slicing] exporting project to 'slicing_result'...
[slicing] applying all slicing requests...
[slicing] applying 0 actions...
[sparecode] remove unused global declarations from project 'slicing_result tmp'
[sparecode] removed unused global declarations in new project 'slicing_result'
After Slicing :
/* Generated by Frama-C */
extern int g(int x);

int f_s_2(int c, int x)
{
  int y;
  int tmp;
  int r;
  if (c) tmp = 1; else tmp = -1;
  y = tmp;
  if (y < 0) r = x + y; else r = 0;
  r = g(r);
  return r;
}

int f(int c, int x)
{
  int y;
  int tmp;
  int r;
  if (c) tmp = 1; else tmp = -1;
  y = tmp;
  if (y < 0) r = x + y; else r = 0;
  r = g(r);
  return r;
}

int main(int x)
{
  int r;
  if (x > 0) r = f(0,x); else r = f_s_2(1,x);
  return r;
}


[value] Analyzing a complete application starting at main
[value] Computing initial state
[value] Initial state computed
[value] Values of globals at initialization
  
[value] computing for function f <- main.
        Called from tests/slicing/combine.c:24.
[value] computing for function g <- f <- main.
        Called from tests/slicing/combine.c:17.
tests/slicing/combine.c:17:[kernel] warning: Neither code nor specification for function g, generating default assigns from the prototype
[value] using specification for function g
[value] Done for function g
[value] Recording results for f
[value] Done for function f
[value] computing for function f_s_2 <- main.
        Called from tests/slicing/combine.c:26.
[value] computing for function g <- f_s_2 <- main.
        Called from tests/slicing/combine.c:17.
[value] Done for function g
[value] Recording results for f_s_2
[value] Done for function f_s_2
[value] Recording results for main
[value] done for function main
After Constant propagation :
/* Generated by Frama-C */
/*@ assigns \result;
    assigns \result \from x; */
extern int g(int x);

int f_s_2(int c, int x)
{
  int y;
  int tmp;
  int r;
  if (1) tmp = 1; else tmp = -1;
  y = 1;
  if (0) r = x + y; else r = 0;
  r = g(0);
  return r;
}

int f(int c, int x)
{
  int y;
  int tmp;
  int r;
  if (0) tmp = 1; else tmp = -1;
  y = -1;
  if (1) r = x + -1; else r = 0;
  r = g(r);
  return r;
}

int main(int x)
{
  int r;
  if (x > 0) r = f(0,x); else r = f_s_2(1,x);
  return r;
}


[sparecode] remove unused code...
[value] Analyzing a complete application starting at main
[value] Computing initial state
[value] Initial state computed
[value] Values of globals at initialization
  
[value] computing for function f <- main.
        Called from tests/slicing/combine.c:24.
[value] computing for function g <- f <- main.
        Called from tests/slicing/combine.c:17.
[value] using specification for function g
[value] Done for function g
[value] Recording results for f
[value] Done for function f
[value] computing for function f_s_2 <- main.
        Called from tests/slicing/combine.c:26.
[value] computing for function g <- f_s_2 <- main.
        Called from tests/slicing/combine.c:17.
[value] Done for function g
[value] Recording results for f_s_2
[value] Done for function f_s_2
[value] Recording results for main
[value] done for function main
[pdg] computing for function main
[from] Computing for function f
[from] Computing for function g <-f
[from] Done for function g
[from] Done for function f
[from] Computing for function f_s_2
[from] Done for function f_s_2
[pdg] done for function main
[pdg] computing for function f_s_2
[pdg] done for function f_s_2
[pdg] computing for function f
[pdg] done for function f
[pdg] computing for function g
[pdg] done for function g
[sparecode] remove unused global declarations...
[sparecode] result in new project 'propagated without sparecode'.
After Sparecode :
/* Generated by Frama-C */
/*@ assigns \result;
    assigns \result \from x; */
extern int g(int x);

int f_s_2(void)
{
  int r;
  r = g(0);
  return r;
}

int f(int x)
{
  int r;
  r = x + -1;
  r = g(r);
  return r;
}

int main(int x)
{
  int r;
  if (x > 0) r = f(x); else r = f_s_2();
  return r;
}


